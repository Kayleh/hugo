<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://kayleh.top/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://kayleh.top/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/github.min.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/github-style.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/light.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/dark.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/syntax.css' />
    <title>concurrency-principle - Kayleh</title>
    
    <link rel="icon" type="image/x-icon" href='https://kayleh.top/images/favicon.ico'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="多线程 为什么要创建线程池 如果系统要运行多个线程,大量反复的启动创建和回收线程会非常占用系统资源,导致性能下降. 创建线程池,可以: 1.降低资源消耗 2.提升响应速度 3.提高
线程池原理  线程池一般由两种角色构成：多个工作线程 和 一个阻塞队列。
  工作线程 : 工作线程是一组已经处在运行中的线程，它们不断地向阻塞队列中领取任务执行。
  阻塞队列 : 阻塞队列用于存储工作线程来不及处理的任务。当工作线程都在执行任务时，到来的新任务就只能暂时在阻塞队列中存储。
   提交一个任务到线程池中,线程池的处理流程如下: 1.判断线程池里的核心线程是否都在执行任务,如果不是(核心线程空闲或者核心线程没有被创建)则创建一个新的工作线程来执行任务.如果核心线程都在执行任务,则进入下个流程. 2.线程池判断工作队列是否已满,如果工作路径没有满,则新提交的任务储存在这个工作队列里.如果工作队列满了,则进入下个流程. 3.判断线程池里的线程是否都处于工作状态,如果没有,则创建一个新的工作线程来执行任务.如果已经满了,则交给饱和策略来处理这个任务. 线程池的分类 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); ThreadPoolExecutor是线程池的真正实现, 他通过构造方法的一系列参数，来构成不同配置的线程池。 corePoolSize： 核心池的大小。 当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中 maximumPoolSize： 线程池最大线程数，它表示在线程池中最多能创建多少个线程； keepAliveTime： 表示线程没有任务执行时最多保持多久时间会终止。 unit： 参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性。 workQueue：一个阻塞队列，提交的任务将会被放到这个队列里。 threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。 handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。
线程池的创建方法 Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：
newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 案例演示:
newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。" />
<meta name="keywords"
  content='' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://kayleh.top/%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="concurrency-principle - Kayleh" />
<meta name="twitter:description"
  content="多线程 为什么要创建线程池 如果系统要运行多个线程,大量反复的启动创建和回收线程会非常占用系统资源,导致性能下降. 创建线程池,可以: 1.降低资源消耗 2.提升响应速度 3.提高
线程池原理  线程池一般由两种角色构成：多个工作线程 和 一个阻塞队列。
  工作线程 : 工作线程是一组已经处在运行中的线程，它们不断地向阻塞队列中领取任务执行。
  阻塞队列 : 阻塞队列用于存储工作线程来不及处理的任务。当工作线程都在执行任务时，到来的新任务就只能暂时在阻塞队列中存储。
   提交一个任务到线程池中,线程池的处理流程如下: 1.判断线程池里的核心线程是否都在执行任务,如果不是(核心线程空闲或者核心线程没有被创建)则创建一个新的工作线程来执行任务.如果核心线程都在执行任务,则进入下个流程. 2.线程池判断工作队列是否已满,如果工作路径没有满,则新提交的任务储存在这个工作队列里.如果工作队列满了,则进入下个流程. 3.判断线程池里的线程是否都处于工作状态,如果没有,则创建一个新的工作线程来执行任务.如果已经满了,则交给饱和策略来处理这个任务. 线程池的分类 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); ThreadPoolExecutor是线程池的真正实现, 他通过构造方法的一系列参数，来构成不同配置的线程池。 corePoolSize： 核心池的大小。 当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中 maximumPoolSize： 线程池最大线程数，它表示在线程池中最多能创建多少个线程； keepAliveTime： 表示线程没有任务执行时最多保持多久时间会终止。 unit： 参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性。 workQueue：一个阻塞队列，提交的任务将会被放到这个队列里。 threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。 handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。
线程池的创建方法 Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：
newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 案例演示:
newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。" />
<meta name="twitter:site" content="https://kayleh.top" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image"
  content="https://kayleh.top">


<meta property="og:type" content="article" />
<meta property="og:title" content="concurrency-principle - Kayleh">
<meta property="og:description"
  content="多线程 为什么要创建线程池 如果系统要运行多个线程,大量反复的启动创建和回收线程会非常占用系统资源,导致性能下降. 创建线程池,可以: 1.降低资源消耗 2.提升响应速度 3.提高
线程池原理  线程池一般由两种角色构成：多个工作线程 和 一个阻塞队列。
  工作线程 : 工作线程是一组已经处在运行中的线程，它们不断地向阻塞队列中领取任务执行。
  阻塞队列 : 阻塞队列用于存储工作线程来不及处理的任务。当工作线程都在执行任务时，到来的新任务就只能暂时在阻塞队列中存储。
   提交一个任务到线程池中,线程池的处理流程如下: 1.判断线程池里的核心线程是否都在执行任务,如果不是(核心线程空闲或者核心线程没有被创建)则创建一个新的工作线程来执行任务.如果核心线程都在执行任务,则进入下个流程. 2.线程池判断工作队列是否已满,如果工作路径没有满,则新提交的任务储存在这个工作队列里.如果工作队列满了,则进入下个流程. 3.判断线程池里的线程是否都处于工作状态,如果没有,则创建一个新的工作线程来执行任务.如果已经满了,则交给饱和策略来处理这个任务. 线程池的分类 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); ThreadPoolExecutor是线程池的真正实现, 他通过构造方法的一系列参数，来构成不同配置的线程池。 corePoolSize： 核心池的大小。 当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中 maximumPoolSize： 线程池最大线程数，它表示在线程池中最多能创建多少个线程； keepAliveTime： 表示线程没有任务执行时最多保持多久时间会终止。 unit： 参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性。 workQueue：一个阻塞队列，提交的任务将会被放到这个队列里。 threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。 handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。
线程池的创建方法 Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：
newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 案例演示:
newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。" />
<meta property="og:url" content="https://kayleh.top/%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/" />
<meta property="og:site_name" content="concurrency-principle" />
<meta property="og:image"
  content="https://kayleh.top">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2019-01-01 13:30:23 &#43;0800 CST" />










</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://kayleh.top">
        <svg class="octicon" height="32" viewBox="0 0 16 16" version="1.1" width="32">
          <path fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd"
            d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          <form target="_blank" action="https://www.google.com/search" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
              <input type="hidden" name="q" value="site:https://kayleh.top">
            </label>
          </form>
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://kayleh.top">
        <svg class="octicon octicon-mark-github v-align-middle" height="32" viewBox="0 0 16 16" version="1.1"
          width="32">
          <path fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>
  
<div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://kayleh.top">
                  <img class=" avatar-user"
                    src="http://cdn.jsdelivr.net/gh/kayleh/cdn/img/2.jpg"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://kayleh.top">Kayleh</a></span><span
                    class="path-divider">/</span><strong class="css-truncate-target mr-1" style="max-width: 410px"><a
                      href="https://kayleh.top/%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/">concurrency-principle</a></strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Tue, 01 Jan 2019 13:30:23 &#43;0800"
                    class="no-wrap">
                    Tue, 01 Jan 2019 13:30:23 &#43;0800</relative-time>

                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div class="file-header d-flex flex-md-items-center flex-items-start">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    3644 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5">
                <article class="markdown-body entry-content container-lg"><h2 id="多线程">多线程</h2>
<h3 id="为什么要创建线程池">为什么要创建线程池</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">如果系统要运行多个线程,大量反复的启动创建和回收线程会非常占用系统资源,导致性能下降.
</code></pre></div><!-- raw HTML omitted -->
<p>创建线程池,可以:
1.降低资源消耗
2.提升响应速度
3.提高</p>
<h3 id="线程池原理">线程池原理</h3>
<blockquote>
<p>线程池一般由两种角色构成：多个工作线程 和 一个阻塞队列。</p>
<ul>
<li>
<p>工作线程 :
工作线程是一组已经处在运行中的线程，它们不断地向阻塞队列中领取任务执行。</p>
</li>
<li>
<p>阻塞队列 :
阻塞队列用于存储工作线程来不及处理的任务。当工作线程都在执行任务时，到来的新任务就只能暂时在阻塞队列中存储。</p>
</li>
</ul>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">提交一个任务到线程池中,线程池的处理流程如下:
1.判断线程池里的核心线程是否都在执行任务,如果不是<span style="color:#f92672">(</span>核心线程空闲或者核心线程没有被创建<span style="color:#f92672">)</span>则创建一个新的工作线程来执行任务.如果核心线程都在执行任务,则进入下个流程.
2.线程池判断工作队列是否已满,如果工作路径没有满,则新提交的任务储存在这个工作队列里.如果工作队列满了,则进入下个流程.
3.判断线程池里的线程是否都处于工作状态,如果没有,则创建一个新的工作线程来执行任务.如果已经满了,则交给饱和策略来处理这个任务.
</code></pre></div><h3 id="线程池的分类">线程池的分类</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ThreadPoolExecutor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> corePoolSize<span style="color:#f92672">,</span>
                              <span style="color:#66d9ef">int</span> maximumPoolSize<span style="color:#f92672">,</span>
                              <span style="color:#66d9ef">long</span> keepAliveTime<span style="color:#f92672">,</span>
                              TimeUnit unit<span style="color:#f92672">,</span>
                              BlockingQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;</span> workQueue<span style="color:#f92672">,</span>
                              ThreadFactory threadFactory<span style="color:#f92672">,</span>
                              RejectedExecutionHandler handler<span style="color:#f92672">);</span>
</code></pre></div><p>ThreadPoolExecutor是线程池的真正实现,
他通过构造方法的一系列参数，来构成不同配置的线程池。
corePoolSize： 核心池的大小。 当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中
maximumPoolSize： 线程池最大线程数，它表示在线程池中最多能创建多少个线程；
keepAliveTime： 表示线程没有任务执行时最多保持多久时间会终止。
unit： 参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性。
workQueue：一个阻塞队列，提交的任务将会被放到这个队列里。
threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。
handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。</p>
<h3 id="线程池的创建方法">线程池的创建方法</h3>
<p>Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：</p>
<p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
案例演示:</p>
<p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p>
<p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">newCachedThreadPool
创建一个可缓存线程池<span style="color:#960050;background-color:#1e0010">，</span>如果线程池长度超过处理需要<span style="color:#960050;background-color:#1e0010">，</span>可灵活回收空闲线程<span style="color:#960050;background-color:#1e0010">，</span>
若无可回收<span style="color:#960050;background-color:#1e0010">，</span>则新建线程<span style="color:#960050;background-color:#1e0010">。</span>

<span style="color:#f92672">package</span> cn.qbz.thread<span style="color:#f92672">;</span>

<span style="color:#f92672">import</span> java.util.concurrent.ExecutorService<span style="color:#f92672">;</span>
<span style="color:#f92672">import</span> java.util.concurrent.Executors<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test111907</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        ExecutorService executorService <span style="color:#f92672">=</span> Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">newCachedThreadPool</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> 10<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
            executorService<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                <span style="color:#a6e22e">@Override</span>
                <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span>1000<span style="color:#f92672">);</span>
                    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
                    <span style="color:#f92672">}</span>
                    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">currentThread</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;   i=&#34;</span> <span style="color:#f92672">+</span> temp<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">});</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> ExecutorService <span style="color:#a6e22e">newCachedThreadPool</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> ThreadPoolExecutor<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">,</span>
                                      60L<span style="color:#f92672">,</span> TimeUnit<span style="color:#f92672">.</span><span style="color:#a6e22e">SECONDS</span><span style="color:#f92672">,</span>
                                      <span style="color:#66d9ef">new</span> SynchronousQueue<span style="color:#f92672">&lt;</span>Runnable<span style="color:#f92672">&gt;());</span>
    <span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">newFixedThreadPool
创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

package cn.qbz.thread;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Test111907 <span style="color:#f92672">{</span>
    public static void main<span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        ExecutorService executorService <span style="color:#f92672">=</span> Executors.newFixedThreadPool<span style="color:#f92672">(</span>3<span style="color:#f92672">)</span>;
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>int i <span style="color:#f92672">=</span> 0; i &lt; 10; i++<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            final int temp <span style="color:#f92672">=</span> i;
            executorService.execute<span style="color:#f92672">(</span>new Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                @Override
                public void run<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                    try <span style="color:#f92672">{</span>
                        Thread.sleep<span style="color:#f92672">(</span>100<span style="color:#f92672">)</span>;
                    <span style="color:#f92672">}</span> catch <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        e.printStackTrace<span style="color:#f92672">()</span>;
                    <span style="color:#f92672">}</span>
                    System.out.println<span style="color:#f92672">(</span>Thread.currentThread<span style="color:#f92672">()</span>.getName<span style="color:#f92672">()</span> + <span style="color:#e6db74">&#34;   i=&#34;</span> + temp<span style="color:#f92672">)</span>;
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">})</span>;
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>


    public static ExecutorService newFixedThreadPool<span style="color:#f92672">(</span>int nThreads<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> new ThreadPoolExecutor<span style="color:#f92672">(</span>nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;<span style="color:#f92672">())</span>;
    <span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">newScheduledThreadPool
创建一个定长线程池，支持定时及周期性任务执行。

package cn.qbz.thread;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class Test111907 <span style="color:#f92672">{</span>
    public static void main<span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        final long begin <span style="color:#f92672">=</span> System.currentTimeMillis<span style="color:#f92672">()</span>;
        ExecutorService executorService <span style="color:#f92672">=</span> Executors.newScheduledThreadPool<span style="color:#f92672">(</span>3<span style="color:#f92672">)</span>;
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>int i <span style="color:#f92672">=</span> 0; i &lt; 10; i++<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            final int temp <span style="color:#f92672">=</span> i;
            final long time <span style="color:#f92672">=</span> begin;
            executorService.schedule<span style="color:#f92672">(</span>new Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                @Override
                public void run<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                    try <span style="color:#f92672">{</span>
                        Thread.sleep<span style="color:#f92672">(</span>100<span style="color:#f92672">)</span>;
                    <span style="color:#f92672">}</span> catch <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        e.printStackTrace<span style="color:#f92672">()</span>;
                    <span style="color:#f92672">}</span>
                    System.out.println<span style="color:#f92672">(</span>Thread.currentThread<span style="color:#f92672">()</span>.getName<span style="color:#f92672">()</span> + <span style="color:#e6db74">&#34;   i=&#34;</span> + temp + <span style="color:#e6db74">&#34;   time=&#34;</span> + <span style="color:#f92672">(</span>System.currentTimeMillis<span style="color:#f92672">()</span> - time<span style="color:#f92672">))</span>;
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>, 5, TimeUnit.SECONDS<span style="color:#f92672">)</span>;
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
    public static ScheduledExecutorService newScheduledThreadPool<span style="color:#f92672">(</span>int corePoolSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> new ScheduledThreadPoolExecutor<span style="color:#f92672">(</span>corePoolSize<span style="color:#f92672">)</span>;
    <span style="color:#f92672">}</span>
    public ScheduledThreadPoolExecutor<span style="color:#f92672">(</span>int corePoolSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        super<span style="color:#f92672">(</span>corePoolSize, Integer.MAX_VALUE, 0, TimeUnit.NANOSECONDS,
              new DelayedWorkQueue<span style="color:#f92672">())</span>;
    <span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">newSingleThreadExecutor
创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，
保证所有任务按照指定顺序<span style="color:#f92672">(</span>FIFO, LIFO, 优先级<span style="color:#f92672">)</span>执行。
public class Test111907 <span style="color:#f92672">{</span>
    public static void main<span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        ExecutorService executorService <span style="color:#f92672">=</span> Executors.newSingleThreadExecutor<span style="color:#f92672">()</span>;
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>int i <span style="color:#f92672">=</span> 0; i &lt; 10; i++<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            final int temp <span style="color:#f92672">=</span> i;
            executorService.execute<span style="color:#f92672">(</span>new Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                @Override
                public void run<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                    try <span style="color:#f92672">{</span>
                        Thread.sleep<span style="color:#f92672">(</span>100<span style="color:#f92672">)</span>;
                    <span style="color:#f92672">}</span> catch <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                        e.printStackTrace<span style="color:#f92672">()</span>;
                    <span style="color:#f92672">}</span>
                    System.out.println<span style="color:#f92672">(</span>Thread.currentThread<span style="color:#f92672">()</span>.getName<span style="color:#f92672">()</span> + <span style="color:#e6db74">&#34;   i=&#34;</span> + temp<span style="color:#f92672">)</span>;
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">})</span>;
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h4 id="关闭线程池"><strong>关闭线程池</strong></h4>
<p>关闭线程池有两种方式：shutdown和shutdownNow，关闭时，会遍历所有的线程，调用它们的interrupt函数中断线程。但这两种方式对于正在执行的线程处理方式不同。</p>
<ol>
<li>
<p>shutdown()
仅停止阻塞队列中等待的线程，那些正在执行的线程就会让他们执行结束。</p>
</li>
<li>
<p>shutdownNow()
不仅会停止阻塞队列中的线程，而且会停止正在执行的线程。</p>
</li>
</ol>
<h3 id="threadpoolexecutor运行机制"><strong>ThreadPoolExecutor运行机制</strong></h3>
<p>当有请求到来时：</p>
<ol>
<li>若当前实际线程数量 少于 corePoolSize，即使有空闲线程，也会创建一个新的工作线程；</li>
<li>若当前实际线程数量处于corePoolSize和maximumPoolSize之间，并且阻塞队列没满，则任务将被放入阻塞队列中等待执行；</li>
<li>若当前实际线程数量 小于 maximumPoolSize，但阻塞队列已满，则直接创建新线程处理任务；</li>
<li>若当前实际线程数量已经达到maximumPoolSize，并且阻塞队列已满，则使用饱和策略。</li>
</ol>
<h3 id="设置合理的线程池大小">设置合理的线程池大小</h3>
<p>任务一般可分为：CPU密集型、IO密集型、混合型，对于不同类型的任务需要分配不同大小的线程池。</p>
<p>CPU密集型任务</p>
<ul>
<li>尽量使用较小的线程池，一般为CPU核心数+1。
因为CPU密集型任务使得CPU使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。</li>
<li>IO密集型任务
可以使用稍大的线程池，一般为2*CPU核心数。
IO密集型任务CPU使用率并不高，因此可以让CPU在等待IO的时候去处理别的任务，充分利用CPU时间。</li>
<li>混合型任务
可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。
只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。
因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。</li>
</ul>
<h3 id="executor两级调度模型"><strong>Executor两级调度模型</strong></h3>
<p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/%E5%B9%B6%E5%8F%91%EF%BC%9A%E5%8E%9F%E7%90%86/20200531201400425.png" alt="在这里插入图片描述"></p>
<p>在HotSpot虚拟机中，Java中的线程将会被一一映射为操作系统的线程。
在Java虚拟机层面，用户将多个任务提交给Executor框架，Executor负责分配线程执行它们；
在操作系统层面，操作系统再将这些线程分配给处理器执行。</p>
<p><strong>Executor结构</strong><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/%E5%B9%B6%E5%8F%91%EF%BC%9A%E5%8E%9F%E7%90%86/20200531201434168.png" alt="在这里插入图片描述"></p>
<p>Executor框架中的所有类可以分成三类：</p>
<ol>
<li>任务
任务有两种类型：Runnable和Callable。</li>
<li>任务执行器
Executor框架最核心的接口是Executor，它表示任务的执行器。
Executor的子接口为ExecutorService。
ExecutorService有两大实现类：ThreadPoolExecutor和ScheduledThreadPoolExecutor。</li>
<li>执行结果
Future接口表示异步的执行结果，它的实现类为FutureTask。</li>
</ol>
<p><strong>线程池</strong>
Executors工厂类可以创建四种类型的线程池，通过Executors.newXXX即可创建。</p>
<p><strong>1. FixedThreadPool</strong></p>
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads){
    return new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/%E5%B9%B6%E5%8F%91%EF%BC%9A%E5%8E%9F%E7%90%86/20200531201545835.png" alt="v2-984ba405f67249ab3cc043c75dbcbedd_hd.jpg"></p>
<ul>
<li>它是一种固定大小的线程池；</li>
<li>corePoolSize和maximunPoolSize都为用户设定的线程数量nThreads；</li>
<li>keepAliveTime为0，意味着一旦有多余的空闲线程，就会被立即停止掉；但这里keepAliveTime无效；</li>
<li>阻塞队列采用了LinkedBlockingQueue，它是一个无界队列；</li>
<li>由于阻塞队列是一个无界队列，因此永远不可能拒绝任务；</li>
<li>由于采用了无界队列，实际线程数量将永远维持在nThreads，因此maximumPoolSize和keepAliveTime将无效。</li>
</ul>
<p><strong>2. CachedThreadPool</strong></p>
<pre><code>	public static ExecutorService newCachedThreadPool(){
	    return new ThreadPoolExecutor(0,Integer.MAX_VALUE,60L,TimeUnit.MILLISECONDS,new SynchronousQueue&lt;Runnable&gt;());
	}
123
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/%E5%B9%B6%E5%8F%91%EF%BC%9A%E5%8E%9F%E7%90%86/20200531201711284.png" alt="v2-f9cff0865c6143ace452274046322335_hd.jpg"></p>
<ul>
<li>它是一个可以无限扩大的线程池；</li>
<li>它比较适合处理执行时间比较小的任务；</li>
<li>corePoolSize为0，maximumPoolSize为无限大，意味着线程数量可以无限大；</li>
<li>keepAliveTime为60S，意味着线程空闲时间超过60S就会被杀死；</li>
<li>采用SynchronousQueue装等待的任务，这个阻塞队列没有存储空间，这意味着只要有请求到来，就必须要找到一条工作线程处理他，如果当前没有空闲的线程，那么就会再创建一条新的线程。</li>
</ul>
<p><strong>3. SingleThreadExecutor</strong></p>
<pre><code>public static ExecutorService newSingleThreadExecutor(){
    return new ThreadPoolExecutor(1,1,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());
}
123
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/%E5%B9%B6%E5%8F%91%EF%BC%9A%E5%8E%9F%E7%90%86/20200531201806178.png" alt="在这里插入图片描述"></p>
<ul>
<li>它只会创建一条工作线程处理任务；</li>
<li>采用的阻塞队列为LinkedBlockingQueue；</li>
</ul>
<p><strong>4. ScheduledThreadPool</strong></p>
<p>它用来处理延时任务或定时任务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn2/%E5%B9%B6%E5%8F%91%EF%BC%9A%E5%8E%9F%E7%90%86/20200531201835537.png" alt="img"></p>
<ul>
<li>它接收SchduledFutureTask类型的任务，有两种提交任务的方式：</li>
<li>scheduledAtFixedRate</li>
<li>scheduledWithFixedDelay</li>
<li>SchduledFutureTask接收的参数：</li>
<li>time：任务开始的时间</li>
<li>sequenceNumber：任务的序号</li>
<li>period：任务执行的时间间隔</li>
<li>它采用DelayQueue存储等待的任务</li>
<li>DelayQueue内部封装了一个PriorityQueue，它会根据time的先后时间排序，若time相同则根据sequenceNumber排序；</li>
<li>DelayQueue也是一个无界队列；</li>
<li>工作线程的执行过程：</li>
<li>工作线程会从DelayQueue取已经到期的任务去执行；</li>
<li>执行结束后重新设置任务的到期时间，再次放回DelayQueue</li>
</ul>
<p>微信公众号:每日学习干货</p>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://kayleh.top">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://kayleh.top/js/github-style.js"></script>



</html>