<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Kayleh</title>
    <link>https://kayleh.top/posts/</link>
    <description>Recent content in Posts on Kayleh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 Apr 2021 23:53:25 +0800</lastBuildDate><atom:link href="https://kayleh.top/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Base</title>
      <link>https://kayleh.top/base/</link>
      <pubDate>Fri, 23 Apr 2021 23:53:25 +0800</pubDate>
      
      <guid>https://kayleh.top/base/</guid>
      <description>1.getConstructor和getDeclaredConstructor
Class类的getConstructor()方法,无论是否设置setAccessible(),都不可获取到类的私有构造器. Class类的getDeclaredConstructor()方法,可获取到类的私有构造器(包括带有其他修饰符的构造器），但在使用private的构造器时，必须设置setAccessible()为true,才可以获取并操作该Constructor对象。</description>
    </item>
    
    <item>
      <title>Thread Pool</title>
      <link>https://kayleh.top/thread-pool/</link>
      <pubDate>Wed, 21 Apr 2021 00:37:35 +0800</pubDate>
      
      <guid>https://kayleh.top/thread-pool/</guid>
      <description>异步执行的代码
new Thread(r).start(); 统一的工具类，定一个接口来实现。
public interface Executor { public void execute(Runnable r); } // 新线程：直接创建一个新线程运行 class FlashExecutor implements Executor { public void execute(Runnable r) { new Thread(r).start(); } }  假如有 10000 个人都调用这个工具类提交任务，那就会创建 10000 个线程来执行，这肯定不合适吧！能不能控制一下线程的数量呢？
 可以把这个任务 r 丢到一个 tasks 队列中，然后只启动一个线程，就叫它 Worker 线程吧，不断从 tasks 队列中取任务，执行任务。这样无论调用者调用多少次，永远就只有一个 Worker 线程在运行，像这样。
这个设计有了三个重大的意义：
\1. 控制了线程数量。
\2. 队列不但起到了缓冲的作用，还将任务的提交与执行解耦了。
\3. 最重要的一点是，解决了每次重复创建和销毁线程带来的系统开销。
 不过只有一个后台的工作线程 Worker 会不会少了点？还有如果这个 tasks 队列满了怎么办呢？
 Worker 线程的数量要增加，但是具体数量要让使用者决定，调用时传入，就叫核心线程数 corePoolSize 吧。
这样设计。
\1. 初始化线程池时，直接启动 corePoolSize 个工作线程 Worker 先跑着。</description>
    </item>
    
    <item>
      <title>a Lock Based on ReentrantLock</title>
      <link>https://kayleh.top/implement-a-lock-based-on-reentrantlock/</link>
      <pubDate>Tue, 20 Apr 2021 00:59:25 +0800</pubDate>
      
      <guid>https://kayleh.top/implement-a-lock-based-on-reentrantlock/</guid>
      <description>基于 ReentrantLock实现一个锁 package aqsLock; import java.util.concurrent.locks.AbstractQueuedSynchronizer; /** * @Author: Kayleh * @Date: 2021/4/20 0:57 */ public class aqsLock { public void lock() { sync.acquire(1); } public void unlock() { sync.release(1); } private final Sync sync = new Sync(); public static class Sync extends AbstractQueuedSynchronizer { @Override protected boolean tryAcquire(int arg) { // CAS 方式尝试获取锁，成功返回true，失败返回false  if (compareAndSetState(0, 1)) return true; return false; } @Override protected boolean tryRelease(int arg) { // 释放锁  setState(0); return true; } } } 基本功能实现，测试：</description>
    </item>
    
    <item>
      <title>CAS &amp; AQS</title>
      <link>https://kayleh.top/cas-and-aqs/</link>
      <pubDate>Mon, 19 Apr 2021 01:43:22 +0800</pubDate>
      
      <guid>https://kayleh.top/cas-and-aqs/</guid>
      <description>CAS（Compare And Swap）原理分析 字面意思是比较和交换，先看看下面场景（A 和 B 线程同时执行下面的代码）：
int i = 10;	//代码1 i = 10;	//代码2 场景 1：A 线程执行代码 1 和代码 2，然后 B 线程执行代码 1 和代码 2，CAS 成功。
场景 2：A 线程执行代码 1，此时 B 线程执行代码 1 和代码 2，A 线程执行代码 2，CAS 不成功，为什么呢？
因为 A 线程执行代码 1 时候会旧值（i 的内存地址的值 10）保存起来，执行代码 2 的时候先判断 i 的最新值（可能被其他线程修改了）跟旧值比较，如果相等则把 i 赋值为 20，如果不是则 CAS 不成功。CAS 是一个原子性操作，要么成功要么失败，CAS 操作用得比较多的是 sun.misc 包的 Unsafe 类，而 Java 并发包大量使用 Unsafe 类的 CAS 操作，比如：AtomicInteger 整数原子类（本质是自旋锁 + CAS），CAS 不需加锁，提高代码运行效率。也是一种乐观锁方式，我们通常认为在大多数场景下不会出现竞争资源的情况，如果 CAS 操作失败，会不断重试直到成功。</description>
    </item>
    
    <item>
      <title>Head First Map</title>
      <link>https://kayleh.top/head-first-hashmap/</link>
      <pubDate>Sun, 18 Apr 2021 01:31:12 +0800</pubDate>
      
      <guid>https://kayleh.top/head-first-hashmap/</guid>
      <description>深入浅出Map  Map是java里边是一个接口,常见的实现类有HashMap、LinkedHashMap、TreeMap和ConcurrentHashMap
 HashMap底层数据结构是数组+链表/红黑树
LinkedHashMap底层数据结构是数组+链表+双向链表
TreeMap底层数据结构是红黑树
ConcurrentHashMap底层数据结构是数组+链表/红黑树
HashMap  简单总结HashMap：
 无序，允许为null，非同步 底层由散列表(哈希表)实现 初始容量和装载因子对HashMap影响挺大的，设置小了不好，设置大了也不好   new一个hashmap时会发生什么? HashMap有几个构造方法,但最主要的就是指定初始值以及负载因子的大小.如果不指定,默认hashmap的大小为16,负载因子的大小为0.75.
 HashMap的大小只能是2次幂,（因为只有大小为2次幂时，才能合理用位运算替代取模）
假如传一个10进去,实际大小是16.
假如传入一个7进去,hashmap最终大小是8,具体实现在tableSizeFor可以看到
 把元素放进hashmap的时候，需要算出这个元素所在的位置（hash），在hashmap里用的是位运算来代替取模，能够更加高效地算出该元素所在的位置。
而负载因子的大小决定着哈希表的扩容和哈希冲突。
比如默认hashmap的大小为16,负载因子的大小为0.75.这意味着数组最多只能放16×0.75=12个元素，一旦超过12个元素，则哈希表需要扩容。每次Put元素的时候都会检查hashmap的大小有没有超过这个阈值，如果超过则扩容。
鉴于（HashMap的大小只能是2次幂），所以扩容的时候默认扩容为原来的2倍。
 扩容是耗时的,也可以通过调高负载因子来减少扩容.
但是一般不推荐这样做,因为这样意味着哈希冲突的概率会增高,哈希冲突的概率增高同样会耗时(因为查找的速度变慢了)
 Put元素 怎么计算hash？
 put元素的时候，先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。好处是增加了随机性，减少了碰撞冲突的可能性。
 put和get的实现
put  首先对key做hash运算，计算出该key所在的index。
如果没碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来进行插入。
假如key相同的，则替换到原来的值。最后判断哈希表是否满了（当前哈希表大小×负载因子），如果满了，则扩容。
 get  还是对key做hash运算，计算出该key所在的index，然后判断是否有哈希冲突。
假如没有冲突则直接返回。假设有冲突则判断目前数据结构是链表还是红黑树，分别从不同的数据结构中取出。
 在hashmap中，怎么判断一个元素是否相同？ 首先比较hash值，随后会用==运算符和equals()来判断该元素是否相同。
说白了，就是：
如果只有hash值相同，那说明该元素hash冲突了，如果hash值和equal() || == 都相同，那说明该元素是同一个。
什么情况下会转红黑树？  当数组大小&amp;gt;64且链表的大小&amp;gt;8的时候才会将链表转为红黑树。当红黑树大小为6时，会退化为链表。
这里转红黑树退化为链表的操作主要出于查询和插入时对性能的考量
链表的查询时间复杂度为O(N),插入时间复杂度为O(1),红黑树查询和插入时间复杂度为O(logN)
 线程安全？  HashMap是线程不安全的，在多线程环境下，HashMap有可能会有数据丢失和获取不了最新数据的问题，比如线程A put进去了，线程B get不出来。
 LinkedHashMap  实际上继承了HashMap，在HashMap的基础上维护了一个双向链表。</description>
    </item>
    
    <item>
      <title>Spring Cyclic Ependencies</title>
      <link>https://kayleh.top/spring-cyclic-ependencies/</link>
      <pubDate>Fri, 16 Apr 2021 23:36:37 +0800</pubDate>
      
      <guid>https://kayleh.top/spring-cyclic-ependencies/</guid>
      <description>Spring是怎么解决循环依赖的？ 首先站在Spring整个Framework体系而言的话，Spring的Bean是由一个BeanDefinition来的，就是在Spring当中，有一个叫建模的类BeanDefinition，Spring的Bean有一系列比较复杂的生命周期：
  首先，Spring容器启动。
  spring进行扫描
  反射后封装成beanDefinition对象，放入beanDefinitionMap
  遍历map
  验证（是否单例、是否延迟加载、是否抽象）
  推断构造方法（ 把当前这个Spring Bean所代表的类当中的构造方法得到一个最佳的一个构造方法 ）
  准备开始进行实例
  去单例池中查，没有——》去二级缓存中找，没有提前暴露——》生成一个objectFactory对象暴露到二级缓存中——》属性注入，发现依赖Y——》此时Y开始它的生命周期直到属性注入，发现依赖X-&amp;gt;X又走一遍生命周期，当走到去二级缓存中找的时候找到了-&amp;gt;往Y中注入X的objectFactory对象-&amp;gt;完成循环依赖。
  1、为什么要使用X的objectFacory对象而不是直接使用X对象？
 利于拓展，程序员可以通过beanPostProcess接口操作objectFactory对象生成自己想要的对象
 2、是不是只能支持单例(scope=singleton)而不支持原型(scope=prototype)？
 是。因为单例是spring在启动时进行bean加载放入单例池中，在依赖的bean开始生命周期后，可以直接从二级缓存中取到它所依赖的bean的objectFactory对象从而结束循环依赖。而原型只有在用到时才会走生命周期流程，但是原型不存在一个已经实例化好的bean，所以会无限的创建-&amp;gt;依赖-&amp;gt;创建-&amp;gt;依赖-&amp;gt;&amp;hellip;。
 3、循环依赖是不是只支持非构造方法？
 是。类似死锁问题
 </description>
    </item>
    
    <item>
      <title>Head First Nginx</title>
      <link>https://kayleh.top/head-first-nginx/</link>
      <pubDate>Thu, 15 Apr 2021 13:55:17 +0800</pubDate>
      
      <guid>https://kayleh.top/head-first-nginx/</guid>
      <description>公司产品出现瓶颈？ 我们公司项目刚刚上线的时候，并发量小，用户使用的少，所以在低并发的情况下，一个jar包启动应用就够了，然后内部tomcat返回内容给用户。 但是慢慢的，使用我们平台的用户越来越多了，并发量慢慢增大了，这时候一台服务器满足不了我们的需求了。 于是我们横向扩展，又增加了服务器。这个时候几个项目启动在不同的服务器上，用户要访问，就需要增加一个代理服务器了，通过代理服务器来帮我们转发和处理请求。 我们希望这个代理服务器可以帮助我们接收用户的请求，然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的，用户并不知道是哪个服务器返回的结果，我们还希望他可以按照服务器的性能提供不同的权重选择。保证最佳体验！所以我们使用了Nginx。
什么是Nginx？ Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日，nginx 1.0.4发布。
其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。
Nginx 是一个安装非常的简单、配置文件非常简洁（还能够支持perl语法）、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。
Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达 50,000 个并发连接数的响应。
Nginx作用？  Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。
 正向代理 反向代理  Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Ip hash。扩展策略，就天马行空，只有你想不到的没有他做不到的。
 轮询 加权轮询 iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不共享的问题。  动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度。
 目前，通过使用Nginx大大提高了我们网站的响应速度，优化了用户体验，让网站的健壮性更上一层楼！
Nginx的安装 windows下安装 1、下载nginx
http://nginx.org/en/download.html 下载稳定版本。 以nginx/Windows-1.16.1为例，直接下载 nginx-1.16.1.zip。 下载后解压，解压后如下：
2、启动nginx
有很多种方法启动nginx
(1)直接双击nginx.exe，双击后一个黑色的弹窗一闪而过
(2)打开cmd命令窗口，切换到nginx解压目录下，输入命令 nginx.exe ，回车即可
3、检查nginx是否启动成功
直接在浏览器地址栏输入网址 http://localhost:80 回车，出现以下页面说明启动成功！
4、配置监听
nginx的配置文件是conf目录下的nginx.conf，默认配置的nginx监听的端口为80，如果80端口被占用可以修改为未被占用的端口即可。
当我们修改了nginx的配置文件nginx.conf 时，不需要关闭nginx后重新启动nginx，只需要执行命令 nginx -s reload 即可让改动生效
5、关闭nginx
如果使用cmd命令窗口启动nginx， 关闭cmd窗口是不能结束nginx进程的，可使用两种方法关闭nginx
(1)输入nginx命令 nginx -s stop(快速停止nginx) 或 nginx -s quit(完整有序的停止nginx)</description>
    </item>
    
    <item>
      <title>Web Test Combat</title>
      <link>https://kayleh.top/web-test-combat/</link>
      <pubDate>Wed, 14 Apr 2021 00:50:01 +0800</pubDate>
      
      <guid>https://kayleh.top/web-test-combat/</guid>
      <description>Web测试要点   功能测试 -(最基本)
  链接测试
1.所有链接是否链接到该链接的页面
2.页面是否存在
3.不存在孤立页面
  表单测试
1提交数据&amp;mdash;-&amp;gt;注册(数据库 新增), 修改订单(数据库 改)
常用控件:输入框,下拉框,上传文件(图片,Excel,txt等),提交按钮,单选多选  输入框:长度,数据类型,必填,重复 空格和业务约束 下拉框:默认信息,数据完整性/正确性,第一条最后一条 上传文件(图片,Excel,txt等):大小,格式,尺寸,数量等. 文件本身的内容规则验证 提交按钮:支持回车/单击;弱网测试 ,快速点击是否重复提交,提交内容是否涉及加密    搜索测试
  输入框(按时间搜索),下拉框
  假设:搜索条件A,B,C,D
  任单个条件查询:下拉框,输入框(模糊搜索,超长搜索,不存在条件,为空)
  时间搜索
开始时间,结束时间
开始时间=结束时间 ( 同一天数据)
开始时间&amp;lt;结束时间(造跨年 跨天 跨月的数据)
开始时间&amp;gt;结束时间(异常)
手动输入,格式
    删除测试
 没有数据,删除 选择一条数据/批量选择/全选,删除. 删除二次确认.且删除后合理提示 删除数据关联性 数据库角度,删,确认数据库是否及时更新    cookie,session测试
 存储用户信息的,记录用户身份给予后续操作通行证 确认浏览器存储cookie目录有无cookie相关信息 保存时间之外,cookie是否正常 删除浏览器所有的cookie文件,再次登录,会怎么处理 鉴权    数据库测试</description>
    </item>
    
    <item>
      <title>Reflected XSS Vulnerability in Font Download Website</title>
      <link>https://kayleh.top/reflected-xss-vulnerability-in-font-download-website/</link>
      <pubDate>Sun, 11 Apr 2021 02:26:29 +0800</pubDate>
      
      <guid>https://kayleh.top/reflected-xss-vulnerability-in-font-download-website/</guid>
      <description>字体下载网站的反射XSS漏洞  URL:http://www.ztxz.org
 搜索框输入：
&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; 会出现弹窗，证明反射XSS的存在。
 http://www.ztxz.org/search/?key=%3Cscript%3Ealert(1)%3C/script%3E
 用户在请求某条URL地址的时候，会携带一部分数据。当客户端进行访问某条链接时，攻击者可以将恶意代码植入到URL，如果服务端未对URL携带的参数做判断或者过滤处理，直接返回响应页面，那么XSS攻击代码就会一起被传输到用户的浏览器，从而触发反射型XSS。例如，当用户进行搜索时，返回结果通常会包括用户原始的搜索内容，如果攻击者精心构造包含XSS恶意代码的链接，诱导用户点击并成功执行后，用户的信息就可以被窃取，甚至可以模拟用户进行一些操作。它的利用过程如图所示。
反射型XSS不会永久存储用户的数据，仅发生在用户的一次访问过程之后。这个过程就像一次反射，因此得名反射型XSS。反射型XSS的触发条件比较苛刻，需要攻击者想方设法引导用户点击链接，但产生的危害不容忽视。
参考资料：https://www.bugbank.cn/q/article/598438535ecec4fe1c216740.html
http://blog.csdn.net/binyao02123202/article/details/9041113</description>
    </item>
    
    <item>
      <title>SQL injection</title>
      <link>https://kayleh.top/sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Tue, 06 Apr 2021 09:48:59 +0800</pubDate>
      
      <guid>https://kayleh.top/sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</guid>
      <description>SQL注入  https://www.bugbank.cn/q/article/5983ea82cbb936102d3977bb.html
 常见的几种SQL注入  1.数字型 2.字符型 3.文本型 4.搜索型(POST/GET) 5.cookie注入 6.SQL盲注 7.编码注入 8.宽字节注入
 MySQL报错注入基本流程  1.判断sql注入 2.数据库权限判断 3.判断字段数 4.查询库名 5.查表名 6.查字段 7.查数据
 1.数字型 1.判断sql注入
  提交单引号
http://localhost/sqls/index.php?id=2&amp;#39;   and大法和or大法
在参数后面加上and 1 = 1
http://localhost/sqls/index.php?id=2 and 1 = 1 //可以查询 http://localhost/sqls/index.php?id=2 and 1 = 2	//查询错误 可以发现and 1=1 返回了数据，而and 1=2没有，这是由于1=1是一个为真的条件，前面的结果是true，true and true 所以没有任何问题，第二个 1=2 是个假条件， true and false还是false，所以并没有数据返回。
接下来看下or、or就是或者，两个都为假，才会为假，只要一个为真就为真，把语句后面的id改成一个不存在的，后面接上or 1=1，这样的话就成了 false or true，结果为true。
http://localhost/sqls/index.php?id=5 or 1 = 1   加法和减法</description>
    </item>
    
    <item>
      <title>Front end security</title>
      <link>https://kayleh.top/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</link>
      <pubDate>Sun, 04 Apr 2021 23:56:49 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/</guid>
      <description> 前端安全
 xss 跨站脚本攻击，是WEB程序中一种常见的漏洞。其主要的攻击手段是在在利用网站上的可由用户输入信息的地方，恶意注入含有攻击性的脚本，达到攻击网站或者窃取用户cookied等隐私信息的目的。
 XSS漏洞测设流程： 第一步：在目标站点上找到输入点，比如查询接口，留言板等； 第二步：输入一组“特殊字符+唯一识别字符”，点击提交，查看返回的源码，是否有做对应的处理； 第三步：通过搜索定位到唯一字符，结合唯一字符前后语法确认是否可以构成执行js的条件（构造闭合） 第四步：提交构造的脚本代码（以及各种绕过姿势），看是否可以成功执行，如果成功执则说明存在XSS漏洞
 Html5存储 </description>
    </item>
    
    <item>
      <title>What happened from entering the URL to displaying the page?</title>
      <link>https://kayleh.top/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/</link>
      <pubDate>Wed, 31 Mar 2021 01:22:51 +0800</pubDate>
      
      <guid>https://kayleh.top/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/</guid>
      <description>从输入URL到显示页面经历了什么?    这个过程可以大致分为两个部分：网络通信和页面渲染。
一、网络通信 互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。分层由高到低分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接收端从数据链路层网上走。如图所示：

1. 在浏览器中输入url 用户输入url，例如http://www.baidu.com。其中http为协议，www.baidu.com为网络地址，及指出需要的资源在那台计算机上。一般网络地址可以为域名或IP地址，此处为域名。使用域名是为了方便记忆，但是为了让计算机理解这个地址还需要把它解析为IP地址。
2.应用层DNS解析域名 客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直至找到或到根节点。
 DNS中递归查询和迭代查询的区别  1、 递归查询： 一般客户机和服务器之间属递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到结果后转交客户机。
2、 迭代查询（反复查询）： 一般DNS服务器之间属迭代查询，如：若DNS2不能响应DNS1的请求，则它会将DNS3的IP给DNS2，以便其再向DNS3发出请求。
以一个DNS请求解析为例：
1）用户发起域名请求到dnsA，这时dnsA有这个记录，将结果返回给用户，这个过程是递归查询。
2）用户发起域名请求到dnsA，这时dns没有这个记录，它去向dnsB问有没有这个记录，以此类推，直到把结果返回给用户，这个过程是递归查询。
3）用户发起域名请求到dnsA，这时dnsA没有这个记录，它告诉用户，我没有这个记录，你去问dnsB吧，这个过程是迭代查询。
3.应用层客户端发送HTTP请求 HTTP请求包括请求报头和请求主体两个部分，其中请求报头包含了至关重要的信息，包括请求的方法（GET / POST）、目标url、遵循的协议（http / https / ftp…），返回的信息是否需要缓存，以及客户端是否发送cookie等。
4.传输层TCP传输报文 位于传输层的TCP协议为传输报文提供可靠的字节流服务。它为了方便传输，将大块的数据分割成以报文段为单位的数据包进行管理，并为它们编号，方便服务器接收时能准确地还原报文信息。TCP协议通过“三次握手”等方法保证传输的安全可靠。
“三次握手”的过程是，发送端先发送一个带有SYN（synchronize）标志的数据包给接收端，在一定的延迟时间内等待接收的回复。接收端收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。

5.网络层IP协议查询MAC地址 IP协议的作用是把TCP分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的MAC地址，也就是物理地址。IP地址和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议可以将IP地址解析成对应的MAC地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。
6.数据到达数据链路层 在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束
7.服务器接收数据 接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文。
8.服务器响应请求 服务接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息——状态码。状态码由三位数字组成，其中比较常见的是200 OK表示请求成功。301表示永久重定向，即请求的资源已经永久转移到新的位置。在返回301状态码的同时，响应报文也会附带重定向的url，客户端接收到后将http请求的url做相应的改变再重新发送。404 not found 表示客户端请求的资源找不到。
9. 服务器返回相应文件 请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。
二、页面渲染 现代浏览器渲染页面的过程是这样的：解析HTML以构建DOM树 –&amp;gt; 构建渲染树 –&amp;gt; 布局渲染树 –&amp;gt; 绘制渲染树。
DOM树是由HTML文件中的标签排列组成，渲染树是在DOM树中加入CSS或HTML中的style样式而形成。渲染树只包含需要显示在页面中的DOM元素，像元素或display属性值为none的元素都不在渲染树中。
在浏览器还没接收到完整的HTML文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送HTTP请求重复上述的步骤。在收到CSS文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。
   </description>
    </item>
    
    <item>
      <title>Download</title>
      <link>https://kayleh.top/download/</link>
      <pubDate>Tue, 16 Mar 2021 01:18:07 +0800</pubDate>
      
      <guid>https://kayleh.top/download/</guid>
      <description>Java 多线程下载器的设计与实现 应用并发的场景有很多，下载文件就是一个很常见的并发场景。
为什么会想写多线程下载器呢？不知道你用过 IDM（Internet Download Manager）没，我刚使用 IDM 时，就被它的下载方式吸引了。
用 IDM 下载文件时，能够直观地看到它的下载过程：固定用 N 个线程下载文件，一开始先将文件分为 N 段，每段用一个线程下载，当某一段下载完成之后，对应的线程就空闲了，此时怎么做呢？从剩余的 N - 1 段中取出最大的一段，一分为二，这样就又有了 N 段的数据，让空闲的线程去下载新划分出来的这一段。
每当有一个线程完成下载任务时，就不断从剩余的部分中划分出一段给它下载，直到整个文件的所有部分都下载完毕。
当然，文件并不能被无限地分段，IDM 会设定一个段的阈值，当剩余的最大段小于这个阈值的时候，就不再分段了给空闲的线程了，只等待活动中的所有线程下载完毕。
说完 IDM 的下载策略，我们大致有了思路。不过优秀的软件不是一蹴而就的，虽然我们想写出像 IDM 的下载器，但还需要从简单的实现开始，不断迭代优化。
所以我们一开始采用的策略是：固定 N 个线程，并将文件划分为 N 段，每个线程负责下载一段数据。
实现步骤 判断服务器是否支持断点续传
首先要明确的是，多线程下载文件利用的是每个线程下载文件的一部分，那么就需要 HTTP 服务器支持请求部分数据，或者说断点续传，因此第一步需要判断目标文件是否支持断点续传。
HTTP 请求头中有一个 Range 字段，可以用来指定要请求的数据范围，例如我们要请求从第 10 字节到第 20 字节的数据，可以将该字段写为 Range:bytes=10-20。
相应的，如果 HTTP 服务器支持断点续传，那么对于指定了 Range 字段的请求，会返回 206 状态码。
我们用 Curl 来测试一下：
curl -I --header &amp;#34;Range: bytes=0-&amp;#34; http://mirrors.163.com/debian/ls-lR.gz 得到的响应：
HTTP/1.1 206 Partial Content Server: nginx Date: Wed, 25 Apr 2018 02:57:56 GMT Content-Type: application/octet-stream Content-Length: 15316619 Connection: keep-alive Last-Modified: Mon, 23 Apr 2018 14:38:44 GMT ETag: &amp;quot;5addeff4-e9b68b&amp;quot; Content-Range: bytes 0-15316618/15316619 我们设置 Range: bytes=0- ，表示请求从第 0 字节到最后一字节的数据，那为什么还要指定该字段呢？这是出于两方面的原因：一是判断响应的状态码是否为 206，二是得到文件的大小。</description>
    </item>
    
    <item>
      <title>app test</title>
      <link>https://kayleh.top/app-test/</link>
      <pubDate>Thu, 04 Mar 2021 00:49:54 +0800</pubDate>
      
      <guid>https://kayleh.top/app-test/</guid>
      <description>移动端测试要点 安装测试、卸载测试 UI测试 功能测试 运行app 应用的前后台切换 免登陆 数据更新 离线浏览 app更新 定位、照相机服务 时间测试 PUSH测试 性能测试 交叉事件测试 例如：微信视频和来电
兼容性测试 升级、更新测试 用户体验测试 硬件环境测试 接口测试 客户端数据库测试 安全测试 Android测试 Android系统的基本结构
 linux内核层
Android函数库和Android运行的虚拟机
应用程序框架
应用程序
 测试术语  系 统碎片化 屏幕尺寸 分辨率 像素 网络制式  像素 一位=8字节
大小 1156*634 = 732904
732904/8=9291613=92K
9291613/1024=89.
网络制式 Android四大组件  缺一不可
  活动   服务   内容提供者   广播接受者  Android测试环境搭建 1️⃣真机测试 使用真实的手机测试
2️⃣安卓模拟器 3️⃣Android自带的模拟器 4️⃣云真机测试 Android开发环境  安装java, jdk ADT工具包  环境配置 打开eclipse</description>
    </item>
    
    <item>
      <title>interface test</title>
      <link>https://kayleh.top/interface-test/</link>
      <pubDate>Sun, 21 Feb 2021 01:49:12 +0800</pubDate>
      
      <guid>https://kayleh.top/interface-test/</guid>
      <description>接口测试  测试系统内部各个组件间接口,以及系统与外部系统之间的交互点
 接口的必要条件 接口用例设计 HTTP协议 HTTP响应状态码分类 POSTMAN 发送不带参数的GET请求 发送带参数的GET请求 参数化运行 csv文件
JSON Postman中的断言 450</description>
    </item>
    
    <item>
      <title>Unitest framework</title>
      <link>https://kayleh.top/unitest-framework/</link>
      <pubDate>Sat, 13 Feb 2021 00:00:57 +0800</pubDate>
      
      <guid>https://kayleh.top/unitest-framework/</guid>
      <description>多条测试用例 注解方法 五个方法 测试用例testcase 测试集合testsuite 追加单个测试对象  print(re.__dict__)
 追加多个测试对象 TestLoder 第一个参数path：指定存放测试用例的目录（单元测试用例，用unittest框架写的测试用例）
第二个参数pattern：指定匹配规则
TestRunner 状态1 状态2（大于1即可）详细报告  断言 class mymath(): def jia(self,a,b): return a+b; def jian(self,a,b): return a-b def changfa(self,a,b): if b==0: return &amp;#34;error&amp;#34; else: return a/b #代码功能验证 if __name__==&amp;#34;__main__&amp;#34;: mm = mymath() actualValue = m.jia(2,3) expectValue = 5 if actualValue==expectValue: print(&amp;#34;加法功能实现正确&amp;#34;) try: actualValue==mm.jia(&amp;#34;a&amp;#34;,3) except Exception as e: print(&amp;#34;该方法功能实现正确&amp;#34;，e) ----------------------------------------------------------- #导包 import unittest from myMath import mymath #创建单元测试类(继承自unittest.testcase) class myMathTest(unittest.TestCase): #测试用例资源初始化方法 def setUp(self): self.</description>
    </item>
    
    <item>
      <title>Katalon Recorder (Selenium tests generator)</title>
      <link>https://kayleh.top/katalon/</link>
      <pubDate>Tue, 02 Feb 2021 02:42:57 +0800</pubDate>
      
      <guid>https://kayleh.top/katalon/</guid>
      <description>和Selenium IDE类似的工具
Katalon Recorder (Selenium tests generator) </description>
    </item>
    
    <item>
      <title>Dynamic programming动态规划</title>
      <link>https://kayleh.top/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Mon, 01 Feb 2021 02:54:04 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>动态规划
首先，动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。
既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。
动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！
首先，动态规划的穷举有点特别，因为这类问题存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。
而且，动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值。
另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出**正确的「状态转移方程」**才能正确地穷举。
以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：
明确 base case -&amp;gt; 明确「状态」-&amp;gt; 明确「选择」 -&amp;gt; 定义 dp 数组/函数的含义。
按上面的套路走，最后的结果就可以套这个框架：
# 初始化 base case dp[0][0][...] = base # 进行状态转移 for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 求最值(选择1，选择2...) 下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。
一、斐波那契数列 请读者不要嫌弃这个例子简单，只有简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙。想要困难的例子，历史文章里有的是。
1、暴力递归
斐波那契数列的数学形式就是递归的，写成代码就是这样：
int fib(int N) { if (N == 1 || N == 2) return 1; return fib(N - 1) + fib(N - 2); } PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</description>
    </item>
    
    <item>
      <title>automated test：selenium</title>
      <link>https://kayleh.top/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 01 Feb 2021 02:52:47 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</guid>
      <description>Selenium  浏览器插件Selenium IDE
  Selenium 3.0没有RC
 使用：
 Record a new test in a new project  在新项目中录制一个新测试   Open an existing project  打开一个现有项目   Create a new project  创建一个新项目   Close Selenium IDE  关闭Selenium IDE    脚本录制 在浏览器中手动操作，就可以selenium录制出来
断言 导出 Export
python pytest
在python环境下使用selenium 1
2
浏览器驱动webdriver
http://chromedriver.storage.googleapis.com/index.html
放到python目录下（python已添加进系统变量）
webdriver API 键盘事件 key包提供按键方法 使用必须先引用key包：from selenium.webdriver.common.keys import Keys
键盘事件，在现实操作中我们习惯性的按tab见切换到写一个输入或者元素，Key()类几乎提供所有按键的方法：</description>
    </item>
    
    <item>
      <title>Test case</title>
      <link>https://kayleh.top/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</link>
      <pubDate>Mon, 25 Jan 2021 01:51:10 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</guid>
      <description>测试用例 什么是测试用例 测试用例(Test Case)是指对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略。其内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，最终形成文档。简单地认为，测试用例是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，用于核实是否满足某个特定软件需求。
回归测试 模板：（excel）    测试用例编号 测试项 依赖用例 测试步骤 输入数据 预期结果 测试结果 测试人 备注        1、2、        标识符(用例编号)，一般编号规则：TestCase_____项目名称_____模块名称_____功能名称_____0001 测试用例的测试目的。一般情况下，用一句话表明目的。（用谷歌浏览器打开百度首页） 一般功能流程上，下游的功能测试依赖于上游的功能测试的用例 用最朴实的语言，写出来软件的操作步骤，要尽量详细（在文本框输入xxx） 测试数据 准确，在重要的步骤之后，设定预期结果，一般和测试目的密切相关 只有两个，通过/失败（和预期结果）      测试用例编写注意事项 黑盒测试用例设计方法 </description>
    </item>
    
    <item>
      <title>Software testing process</title>
      <link>https://kayleh.top/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sat, 16 Jan 2021 01:17:42 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/</guid>
      <description>软件测试流程 过程模型 ★V模型 ★W模型 H模型 X模型 测试过程理念 软件测试的分类 测试需求分析 1.列出待测需求
2.设定需求优先级
3.详细描述测试需求内容
4.经过评审并通过
5.需求统计及分析
   测试需求编号 测试需求名称 质量特性 所在模块 所在页面 优先级 负责人 版本号 需求详情描述     JXC-SRS-GN-XT-JBXX-001 公司名称 功能特性 系统设置模块 基本信息设置模块 低级 张三 v2.1 1.内容:文本 2.约束:非空                          测试用例 缺陷报告    缺陷编号 缺陷标题 状态(new新提交,open确认修改,fixed修改完成,closed回归通过,reopen回归不通过) 优先级(高,中,低) 严重程度(致命,严重,一般,轻微,建议) 提交人 缺陷描述     1                            QC 需求</description>
    </item>
    
    <item>
      <title>SpringBoot startup process</title>
      <link>https://kayleh.top/springboot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Fri, 15 Jan 2021 20:40:54 +0800</pubDate>
      
      <guid>https://kayleh.top/springboot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E6%B3%A8%E8%A7%A3/</guid>
      <description>SpringBoot应用启动流程 我们将各步骤总结精炼如下：
 通过 SpringFactoriesLoader 加载 META-INF/spring.factories 文件，获取并创建 SpringApplicationRunListener 对象 然后由 SpringApplicationRunListener 来发出 starting 消息 创建参数，并配置当前 SpringBoot 应用将要使用的 Environment 完成之后，依然由 SpringApplicationRunListener 来发出 environmentPrepared 消息 创建 ApplicationContext 初始化 ApplicationContext，并设置 Environment，加载相关配置等 由 SpringApplicationRunListener 来发出 contextPrepared 消息，告知SpringBoot 应用使用的 ApplicationContext 已准备OK 将各种 beans 装载入 ApplicationContext，继续由 SpringApplicationRunListener 来发出 contextLoaded 消息，告知 SpringBoot 应用使用的 ApplicationContext 已装填OK refresh ApplicationContext，完成IoC容器可用的最后一步 由 SpringApplicationRunListener 来发出 started 消息 完成最终的程序的启动 由 SpringApplicationRunListener 来发出 running 消息，告知程序已运行起来了  至此，全流程结束！</description>
    </item>
    
    <item>
      <title>the difference of BIO、NIO、AIO</title>
      <link>https://kayleh.top/bionioaio%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 21 Dec 2020 00:15:14 +0800</pubDate>
      
      <guid>https://kayleh.top/bionioaio%E5%8C%BA%E5%88%AB/</guid>
      <description>BIO、NIO、AIO区别 一、BIO
在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，然后在客户端启动Socket来对服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端会线程会等待请求结束后才继续执行。
二、NIO
NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题： 在使用同步I/O的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个线程来单独处理。这样做虽然可以达到我们的要求，但同时又会带来另外一个问题。由于每创建一个线程，就要为这个线程分配一定的内存空间（也叫工作存储器），而且操作系统本身也对线程的总数有一定的限制。如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，甚至服务器可能会因此而瘫痪。
NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。 也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。
BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。
NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。
在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。
　HTTP/1.1出现后，有了Http长连接，这样除了超时和指明特定关闭的http header外，这个链接是一直打开的状态的，这样在NIO处理中可以进一步的进化，在后端资源中可以实现资源池或者队列，当请求来的话，开启的线程把请求和请求数据传送给后端资源池或者队列里面就返回，并且在全局的地方保持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求，而后端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的.当后端处理完，到全局地方得到现场，产生响应，这个就实现了异步处理。
三、AIO
与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：
 AsynchronousSocketChannel AsynchronousServerSocketChannel AsynchronousFileChannel AsynchronousDatagramChannel  其中的read/write方法，会返回一个带回调函数的对象，当执行完读取/写入操作后，直接调用回调函数。
BIO是一个连接一个线程。
NIO是一个请求一个线程。
AIO是一个有效请求一个线程。
先来个例子理解一下概念，以银行取款为例：
 同步 ： 自己亲自出马持银行卡到银行取钱（使用同步IO时，Java自己处理IO读写）； 异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS需要支持异步IO操作API）； 阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）； 非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行读写，不断循环直到读写完成）  Java对BIO、NIO、AIO的支持：
 Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，  BIO、NIO、AIO适用场景分析:
 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。  另外，I/O属于底层操作，需要操作系统支持，并发也需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。
在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式，其中Reactor模式用于同步I/O，而Proactor运用于异步I/O操作。
在比较这两个模式之前，我们首先的搞明白几个概念，什么是阻塞和非阻塞，什么是同步和异步,同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。
一般来说I/O模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO
同步阻塞IO：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！
同步非阻塞IO:在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。</description>
    </item>
    
    <item>
      <title>Talk about:IO</title>
      <link>https://kayleh.top/%E6%B5%85%E8%B0%88io/</link>
      <pubDate>Sun, 20 Dec 2020 22:45:19 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%B5%85%E8%B0%88io/</guid>
      <description>File对象 在计算机系统中，文件是非常重要的存储方式。Java的标准库java.io提供了File对象来操作文件和目录。
要构造一个File对象，需要传入文件路径：
public class Main { public static void main(String[] args) { File f = new File(&amp;#34;C:\\Windows\\notepad.exe&amp;#34;); System.out.println(f); } } 构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：
File f = new File(&amp;#34;C:\\Windows\\notepad.exe&amp;#34;); 注意Windows平台使用\作为路径分隔符，在Java字符串中需要用\\表示一个\。Linux平台使用/作为路径分隔符：
File f = new File(&amp;#34;/usr/bin/javac&amp;#34;); 传入相对路径时，相对路径前面加上当前目录就是绝对路径：
// 假设当前目录是C:\Docs File f1 = new File(&amp;#34;sub\\javac&amp;#34;); // 绝对路径是C:\Docs\sub\javac File f3 = new File(&amp;#34;.\\sub\\javac&amp;#34;); // 绝对路径是C:\Docs\sub\javac File f3 = new File(&amp;#34;..\\sub\\javac&amp;#34;); // 绝对路径是C:\sub\javac 可以用.表示当前目录，..表示上级目录。
File对象有3种形式表示的路径，一种是getPath()，返回构造方法传入的路径，一种是getAbsolutePath()，返回绝对路径，一种是getCanonicalPath，它和绝对路径类似，但是返回的是规范路径。
什么是规范路径？我们看以下代码：
public class Main { public static void main(String[] args) throws IOException { File f = new File(&amp;#34;.</description>
    </item>
    
    <item>
      <title>off-heap</title>
      <link>https://kayleh.top/%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98/</link>
      <pubDate>Sun, 20 Dec 2020 21:21:38 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98/</guid>
      <description>堆外内存 off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在RAM中。对象在这种状态下不能直接使用，它们必须首先反序列化，也不受垃圾收集。序列化和反序列化将会影响部分性能（所以可以考虑使用FST-serialization）使用堆外内存能够降低GC导致的暂停。堆外内存不受垃圾收集器管理，也不属于老年代，新生代。</description>
    </item>
    
    <item>
      <title>Single point login</title>
      <link>https://kayleh.top/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 17 Dec 2020 14:58:05 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/</guid>
      <description>单点登录实现 分布式Session即Session共享 如果我们是同一个网站，在多台服务器上部署，并且访问同一个域名，这种类似于分布式session，目前比较简单的解决方案用nginx做代理就可以实现。
在单服务器web应用中，登录用户信息只需存在该服务的session中，这是我们几年前最长见的办法。而在当今分布式系统的流行中，微服务已成为主流，用户登录由某一个单点服务完成并存储session后，在高并发量的请求（需要验证登录信息）到达服务端的时候通过负载均衡的方式分发到集群中的某个服务器，这样就有可能导致同一个用户的多次请求被分发到集群的不同服务器上，就会出现取不到session数据的情况，于是session的共享就成了一个问题。目前实现session共享的解决方案：
1）Session复制与共享 多个server之间相互同步session，这样每个server上都包含全部Service的session。
优点：tomcat等多数主流web服务器都支持此功能。
不足：session同步需要数据传输，占内网带宽，有时延。所有服务器都包含所有session数据，特别是当session中保存了较大的对象，而且对象变化较快时，性能下降显著，这种特性使得web应用的水平扩展受到了限制。
2）客户端存储法 服务端存储所有用户的session，内存占用较大，也可以将session存储到浏览器cookie中，每个端只要存储一个用户的数据了。
优点：服务端不需要存储
缺点：每次http请求都携带session，占外网带宽数据存储在端上，并在网络传输，存在泄漏、篡改、窃取等安全隐患。session存储的数据大小受cookie限制。
3）反向代理hash一致性 为了保证高可用，有多台冗余，反向代理层能不能做一些事情，让同一个用户的请求保证落在一台web服务器上呢？具体方案：反向代理使用IP或http协议中的某些业务参数来做hash，以保证同一个浏览器用户的请求落在同一个web服务器上。
优点：只需要改nginx配置，不用改应用代码，负载均衡，只要hash属性是均匀的，多台web服务器的负载是均衡的。可以支持web服务器水平扩展（session同步法是不行的，受内存限制）
缺点：如果web服务器重启，一部分session会丢失，产生业务影响，例如部分用户重新登录。如果web服务器水平扩展，rehash后session重新分布，也会有一部分用户路由不到正确的session。
4）服务端集中存储 将session存储在后端的存储层，如：数据库或者缓存。客户端每发次一次请求，都会先从存储中获取，再处理具体的业务逻辑。
优点：无安全隐患，可以水平扩，服务器重启或者扩容都不会造成session丢失。
不足：增加了一次网络调用，要修改应用代码。
总结：一般对单点登录和session共享的处理，大都选择在服务端集中存储来实现。对于db存储还是cache，肯定cache是首选。因为session读取的频率会很高，使用数据库压力会比较大。如果有session高可用需求，cache可以做高可用，但大部分情况下session可以丢失，一般也不需要考虑高可用。目前主流的现实方案是用redis实现session的存储。
单点登录 如果是不同网站，我们要做到登陆A系统，同时从A系统跳转到B系统并且B系统不用登陆，B系统登录后也可以跳转到A系统并且A系统也不需要登陆，系统可以扩展到N个，这种是单点登录，并且涉及到跨域的处理，这种解决方案目前看来有Oauth2.0，JWT 等单点登录（SSO）框架，并且最好每个系统都集成单点登录才是比较好的，或者做一个认证中心，实现登陆认证中心后可以跳转到A,B系统，这时候A,B系统即可以做单点登录也可以不再做单点登陆</description>
    </item>
    
    <item>
      <title>JMM memory model</title>
      <link>https://kayleh.top/java-memory-model%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 17 Dec 2020 02:40:45 +0800</pubDate>
      
      <guid>https://kayleh.top/java-memory-model%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>所有的Java开发人员可能会遇到这样的困惑？我该为堆内存设置多大空间呢？OutOfMemoryError的异常到底涉及到运行时数据的哪块区域？该怎么解决呢？其实如果你经常解决服务器性能问题，那么这些问题就会变的非常常见，了解JVM内存也是为了服务器出现性能问题的时候可以快速的了解那块的内存区域出现问题，以便于快速的解决生产故障。
先看一张图，这张图能很清晰的说明JVM内存结构布局。
Java的内存结构****：****
JVM内存结构主要有三大块：堆内存、方法区和栈。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配；
方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。
在通过一张图来了解如何通过参数来控制各区域的内存大小
控制参数 -Xms设置堆的最小空间大小。
-Xmx设置堆的最大空间大小。
-XX:NewSize设置新生代最小空间大小。
-XX:MaxNewSize设置新生代最大空间大小。
-XX:PermSize设置永久代最小空间大小。
-XX:MaxPermSize设置永久代最大空间大小。
-Xss设置每个线程的堆栈大小。
没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。
老年代空间大小=堆空间大小-年轻代大空间大小
从更高的一个维度再次来看JVM和系统调用之间的关系
****方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。
下面我们详细介绍每个区域的作用
Java堆（Heap） 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。
根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。
如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
方法区（Method Area） 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。
对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。
Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。
根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
程序计数器（Program Counter Register） 程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。
此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
JVM栈（JVM Stacks） 与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。
其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。
本地方法栈（Native Method Stacks） 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。
总结 1）程序计数器 几乎不占有内存。用于取下一条执行的指令。 2）堆 所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。堆被划分为新生代和旧生代，新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成，结构图如下所示： 新生代。新建的对象都是用新生代分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代 大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例旧生代。用于存放新生代中经过多次垃圾回收仍然存活的对象。</description>
    </item>
    
    <item>
      <title>JVM垃圾回收机制</title>
      <link>https://kayleh.top/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Thu, 17 Dec 2020 01:46:57 +0800</pubDate>
      
      <guid>https://kayleh.top/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid>
      <description>GC是什么 分代收集算法
 次数上频繁收集Young区 Minor GC
次数上较少收集Old区 Full GC
基本不动Perm永久区
 GC是发生在哪个部分  GC是发生在堆(heap)里面的
 GC分几种? 1️⃣引用计数法(被淘汰) 缺点:
 每次对对象赋值时均要维护引用计数器,且计数器本身也有一定的消耗 较难处理循环引用   JVM的实现一般不采用这种方式
 2️⃣复制算法(Copying) 年轻代中使用的是Minor GC,这种GC算法采用的是复制算法(Copying)
原理:
 从根集合(GC Root)开始,通过Tracing从From中找到存活对象,拷贝到To中; From丶To交换身份,下次内存分配从To开始  优势✔️
  没有标记和清除的过程,效率高
  没有内存碎片,可以利用bump-the-pointrt实现快速内存分配
  劣势✖️
 需要双倍空间  3️⃣标记清除(Mark-Sweep) 老年代一般是由标记清除或者是标记清除与标记整理的混合实现
原理
  1.标记(Mark)
从根集合开始扫描,对存活的对象进行标记
  2.清除(Sweep)
扫描整个内存空间,回收未被标记的对象,使用free-list记录可以区域.
  优势✔️
 不需要额外空间  劣势✖️
 两次扫描,耗时严重 会产生内存碎片  4️⃣标记压缩(Mark-Compact) 原理:</description>
    </item>
    
    <item>
      <title>SpringMVC work stream</title>
      <link>https://kayleh.top/springmvc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Wed, 16 Dec 2020 23:13:22 +0800</pubDate>
      
      <guid>https://kayleh.top/springmvc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</guid>
      <description>SpringMVC工作流程   处理模型数据方式一:将方法的返回值设置为ModelAndView
  处理模型数据方式二:方法的返回值仍是String类型,在方法的入参中传入Map,Model或者ModelMap,
不管将处理器方法的返回值设置为ModelAndView还是在方法的入参传入Map,Model或者ModelMap,SpringMVC都会转换为一个ModelAndView对象.
  </description>
    </item>
    
    <item>
      <title>Transaction isolation level</title>
      <link>https://kayleh.top/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link>
      <pubDate>Wed, 16 Dec 2020 22:14:51 +0800</pubDate>
      
      <guid>https://kayleh.top/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid>
      <description>事务的隔离级别 事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。
 **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。  数据库事务并发问题 假设选择有两个事务:Transaction01和Transaction02并发执行.
1)脏读
①Transaction01将某条记录的AGE值从20修改为30.
②Transaction02读取了Transaction01更新后的值:30.
③Transaction01回滚.AGE值恢复到了20.
④Transaction02读取到的30就是一个无效的值.
2)不可重复读
①Transaction01读取了AGE值为20.
②Transaction02将AGE值修改为30.
③Transaction01再次读取AGE值为30,和第一次读取不一致.
3)幻读
①Transaction01读取了STUDENT表中的一部分数据
②Transaction02向STUDENT表中插入了新的行
③Transaction01读取的时候,多了一些新的行,感觉出现了幻觉
隔离级别  一个事务与其他事务隔离的程度称为隔离级别
 1)读未提交:READ UNCOMMITTED
允许Transaction01读取Transaction02未提交的修改
2)读已提交:READ COMMITTED
要求Transaction01只能提取Transaction02已提交的修改
3)可重复读: REPEATABLE READ
确保Transaction01可以多次从一个字段中读取到相同的值,即Transaction01执行期间禁止其他事务对这个字段更新
4)串行化: SERIALIZABLE
确保Transaction01可以多次从一个表中读取到相同的行.在Transaction01执行期间,禁止其他事务对这个表进行添加,更新,删除操作.可以避免任何并发问题,但性能十分低下.
   隔离级别 脏读 不可重复读 幻读.虚拟读取     未提交读 是 是 是   已提交读 否 是 是   可重复读 否 否 是   快照 否 否 否   可序列化 否 否 否    </description>
    </item>
    
    <item>
      <title>Spring Related</title>
      <link>https://kayleh.top/spring%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Wed, 16 Dec 2020 21:44:11 +0800</pubDate>
      
      <guid>https://kayleh.top/spring%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>Spring相关 什么是IOC IOC： Inversion of control 反转控制。 比如以前创建一个对象，需要自己主动new 一个对象，通过IOC，对象的创建交由Spring框架 创建，开发人员直接使用已经创建好的对象。
什么是DI DI： Dependency Injection 依赖注入。 通过IOC创建对象的时候，可以注入字符串甚至其他对象。 比如DAO就会注入session factory.
通常IOC和DI是紧密结合，一起使用的
什么是AOP 把功能划分为核心业务功能和其他的周边辅助功能，比如日志，性能统计，事务等等。 其他的周边辅助功能可以都看作切面功能。核心功能和切面功能分别独立开发，通过面向切面编程，可以有机的把核心业务功能和切面功能根据需求结合在一起。 比如增加操作可以和事务切面结合在一起，查询操作可以和性能统计切面结合在一起。 在配置方面，要配置切面，切点，并且通过aspect:config 把切面和切点结合起来。
bean的作用域  可以通过配置文件的scope属性来指定bean的作用域
  singleton:默认值.当IOC容器一创建就会创建bean的实例.而且是单例的,每次得到的都是同一个. prototype:原型的.当IOC容器一创建不再实例化该bean,每次调用getBean方法时再实例化该bean,而且每次得到的不是同一个 request:每次请求实例化一个bean session:在一次会话中共享一个bean  Spring支持的常用数据库事务传播属性和事务隔离级别   propagation:用来设置事务的传播行为
事务的传播行为:一个事务方法运行在了一个开启了事务的方法中时,当前方法时使用原来的事务还是开启一个新的事务
 Propagation.REQUIRED:默认值,使用原来的事务 Propagation.REQUIRED_NEW:将原来的事务挂起,开启一个新的事务    isolation:用来设置事务的隔离级别
 Isolation.REPEATABLE_READ:可重复读,MySQL默认的隔离级别 Isolation.READ_COMMITTED:读已提交,Oracle默认的隔离级别,开发时通常使用的隔离级别    </description>
    </item>
    
    <item>
      <title>Native method?</title>
      <link>https://kayleh.top/native%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 16 Dec 2020 00:58:42 +0800</pubDate>
      
      <guid>https://kayleh.top/native%E6%96%B9%E6%B3%95/</guid>
      <description>Native 方法? 翻看Thread.start()源码,竟然出现了无方法体的方法??
private native void start0(); 这里其实用到了关键字native
native关键字  说明java的作用范围达不到了,回去调用底层C语言的库.
 使用native关键字会进入本地方法栈,调用本地方法接口JNI(Java Native Interface)
JNI的作用: 扩展Java的使用,融合不同的编程语言为Java所用
它在内存区域中专门开辟了一块标记区域: Native Method Stack,登记Native方法.
在最终执行的时候,加载本地方法库中的方法通过JNI
本地方法的使用 少见.
 Java使用打印机,currentTimeMills( ),做外挂的Robot( )&amp;hellip;
 </description>
    </item>
    
    <item>
      <title>沙箱安全机制</title>
      <link>https://kayleh.top/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 16 Dec 2020 00:58:23 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/</guid>
      <description>什么是沙箱？  Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将 Java 代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。
 所有的Java程序运行都可以指定沙箱，可以定制安全策略。
java中的安全模型：  在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱 (Sandbox) 机制。如下图所示
但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的 Java1.1 版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示
在 Java1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示
当前最新的安全机制实现，则引入了域 (Domain) 的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域 (Protected Domain)，对应不一样的权限 (Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示
以上提到的都是基本的 Java 安全模型概念，在应用开发中还有一些关于安全的复杂用法，其中最常用到的 API 就是 doPrivileged。doPrivileged 方法能够使一段受信任代码获得更大的权限，甚至比调用它的应用程序还要多，可做到临时访问更多的资源。有时候这是非常必要的，可以应付一些特殊的应用场景。例如，应用程序可能无法直接访问某些系统资源，但这样的应用程序必须得到这些资源才能够完成功能。
组成沙箱的基本组件：  字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。 类装载器（class loader）：其中类装载器在3个方面对Java沙箱起作用   它防止恶意代码去干涉善意的代码； 它守护了被信任的类库边界； 它将代码归入保护域，确定了代码可以进行哪些操作。   虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。
 类装载器采用的机制是双亲委派模式。1. 从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；
由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。   存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。 安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。 安全软件包（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：  安全提供者 消息摘要 数字签名 加密 鉴别         说白了就是限制远程代码权限</description>
    </item>
    
    <item>
      <title>JVM classloader and parent delegation-mechanism</title>
      <link>https://kayleh.top/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 14 Dec 2020 21:28:57 +0800</pubDate>
      
      <guid>https://kayleh.top/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</guid>
      <description>JVM-类加载器和双亲委派机制 JVM java的六种存储地址及解释 1） 寄存器(register)：这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。
2） 堆栈(stack)：位于通用RAM中，但通过它的“堆栈指针”可以从处理器哪里获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时候，JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些JAVA数据存储在堆栈中——特别是对象引用，但是JAVA对象不存储其中。
3）堆(heap)：一种通用性的内存池（也存在于RAM中），用于存放所有的JAVA对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区域，也不必知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代码。用堆进行存储分配比用堆栈进行存储存储需要更多的时间。
4）静态存储(static storage)：这里的“静态”是指“在固定的位置”。静态存储里存放程序运行时一直存在的数据。你可用关键字static来标识一个对象的特定元素是静态的，但JAVA对象本身从来不会存放在静态存储空间里。
5） 常量存储(constant storage)：常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分分割离开，所以在这种情况下，可以选择将其放在ROM中。 6） 非RAM存储：如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。
栈、堆、方法区存储的内容
堆区: 1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令) 2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 。
栈区: 1.每个线程包含一个栈区，栈中只保存基础数据类型的值和对象以及基础数据的引用 2.每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。 3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
方法区: 1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。
JVM在什么位置？ 在操作系统之上。
JVM的体系结构 *栈用完系统会自动释放，不会有垃圾
  栈、本地方法栈、程序计数器：百之百没有垃圾，不会有垃圾回收
  JVM调优百分之99都是在调方法区和堆，而百分之99都是再调堆
  类加载器 类加载器的作用？  加载Class文件
 加载器分为  虚拟机自带的加载器 启动类（根）加载器 扩展类加载器 应用程序加载器  类的加载过程 java中类的加载有5个过程，加载、验证、准备、解析、初始化；
这便是类加载的5个过程，而类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例，在虚拟机提供了3种类加载器，引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）。
Class文件中的“类”从加载到JVM内存中，到卸载出内存过程有七个生命周期阶段。类加载机制包括了前五个阶段。
如下图所示：
其中，加载、验证、准备、初始化、卸载的****开始顺序****是确定的，注意，只是按顺序开始，进行与结束的顺序并不一定。解析阶段可能在初始化之后开始。
另外，类加载无需等到程序中“首次使用”的时候才开始，JVM预先加载某些类也是被允许的。（*类加载的时机*）
1、通过一个类的全限定名（包名与类名）来获取定义此类的二进制字节流（Class文件）。而获取的方式，可以通过jar包、war包、网络中获取、JSP文件生成等方式。
2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。这里只是转化了数据结构，并未合并数据。（方法区就是用来存放已被加载的类信息，常量，静态变量，编译后的代码的运行时内存区域）
3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。这个Class对象并没有规定是在Java堆内存中，它比较特殊，虽为对象，但存放在方法区中。
双亲委派模式  升级处理交由最顶级处理 最顶级说我这没你们随便 在降级处理
 双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，所以默认是父装载
 1.</description>
    </item>
    
    <item>
      <title>AIO blocking model</title>
      <link>https://kayleh.top/aio%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 05 Dec 2020 11:57:07 +0800</pubDate>
      
      <guid>https://kayleh.top/aio%E6%A8%A1%E5%9E%8B/</guid>
      <description>AIO模型 1. 在系统层面分析IO模型 当我们从网络中或者其他进程中接收到数据时，这个数据会先被拷贝到系统内核的缓冲区，然后从内核的缓冲区中再复制到我们应用程序对应的缓冲区中，这样我们才能实现从应用程序中取得这个数据。
1.1 BIO模型  我们的应用程序会首先调用特定的函数，这样才能去访问我们的操作系统。拿我们的BIO聊天室来说，我们在服务器上，想看一下客户端从网络上传递过来的数据有没有准备好，那么它会去询问操作系统有没有收到新的数据，如果没有收到，它会一直阻塞在这里，直到收到消息，并且已经从系统内核缓冲区中拷贝到应用程序的缓冲区中，这样这个调用才能够成功返回。这就是阻塞式IO，我们在等待的过程中，什么都做不了。  1.2 NIO模型  当我们的应用程序进行系统调用，询问数据有没有准备好，没有准备好的话，因为它是非阻塞的，所以直接返回；直到系统已经将内核缓冲区中的数据复制到应用程序的缓冲区中，这时我们再去询问数据有没有准备好的话，就能够获取到我们想要的数据了。但是它并不包括Selector监听模式，仅仅是NIO中的非阻塞式模型。  1.2.1 IO多路复用  这个模式对应的就是我们NIO聊天室中采用的模式，使用了Selector监听 首先我们的应用程序发起新的询问，是不是有可用的数据进行操作了，如果数据这时没有准备好，并不会如上NIO直接返回，而是说，我们要求内核监听我们这个IO通道，直到它有了数据可以供我们的程序进行操作了，再来通知我们，这个监听的过程，就像我们聊天室中的select()方法，它是阻塞的。直到数据已经在系统内核缓存区中准备好了，它会通知你一下，告诉你可以执行系统调用，将缓存区中的数据复制到应用程序缓存区中，这时我们才真正获取到了我们想要的数据 在这个时候，系统内核能够监听多个IO通道，跟我们的聊天室一样，它也监听了多个通道，只要其中任何一个IO通道有了新的状态更新，那么这个监听都会返回给我们应用程序说，其中的IO通道有一个或者多个出现了状态的变化，你要不要对其进行处理一下，我们便可以根据它返回的条件，进行特定的处理。（Selector可以翻译成为IO多路复用器）  1.3 AIO模型（异步IO）  BIO和NIO都是同步IO模型，这里我们说说AIO（异步）模型 同步IO模型是当我们访问的这个数据无论有没有准备好，都会返回给你结果；当数据没有准备好的时候，我们没有能够获取数据，如果我们再也不发起获取数据的请求，那么我们永远都不会再获取到这个数据。异步IO就不同了，当你请求这个数据没有请求到，而之后这个数据准备好了，它就会回去通知你，可以来取这个数据了 我们来看一下这个流程：我们去请求数据，数据没有准备好，我们没有被阻塞，而是直接返回了。在应用程序层面，虽然我们没有再发起新的请求，但是在系统后台，会监听这个我们请求数据的状态，当我们需要的数据已经准备好了，并且已经存在于系统内核缓存区中了，系统后台还会将这个数据拷贝到我们的应用程序缓存区中，到这里，系统内核会递交给我们一个信号，告诉你，你之前想要的这个数据，已经准备好给你了，你可以进行使用了。 它的异步体现在：我们程序只对数据发起了一次请求，没有请求到，就直接返回了，而之后，当这个数据已经准备好的时候，系统回来通知我们，而不需要我们再次发起请求，就能获取到这个数据，这就体现了异步的特点。A就是asynchronous，也就是异步的意思   2. 异步调用机制 2.1 AIO中的异步操作  客户端对应AsynchronousSocketChannel 服务端对应AsynchronousServerSocketChannel 建立连接为connect/accept 读操作为read 写操作为write  2.2 通过Future进行异步调用  注意其中Future的get()方法是阻塞式的  2.3 通过CompletionHandler（多用）  在执行操作的时候，传入CompletionHandler参数   3. 实战（回音服务器） 3.1 服务器端 3.1.1 字段 3.1.2 主方法 3.1.3 AcceptHandler的实现 3.1.4 ClientHandler的实现 3.2 客户端 3.2.1 字段 3.2.2 主方法  4.</description>
    </item>
    
    <item>
      <title>NIO blocking model</title>
      <link>https://kayleh.top/nio%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 05 Dec 2020 11:33:46 +0800</pubDate>
      
      <guid>https://kayleh.top/nio%E6%A8%A1%E5%9E%8B/</guid>
      <description>NIO模型 1. 概述 1.1 翻译翻译？什么叫NIO？ NIO：我认为翻译成Non-Blocking，更加的通俗直白，相比于BIO，也有一个对比，叫他非阻塞IO最好不过了
 它和BIO有以下的区别  Channel是双向的，即可以读又可以写，相比于Stream，它并不区分出输入流和输出流，而且Channel可以完成非阻塞的读写，也可以完成阻塞的读写  1.2 Buffer简介  Channel的读写是离不开Buffer的，Buffer实际上内存上一块用来读写的区域。  1.2.1 写模式  其中三个指针我们要了解一下，position为当前指针位置，limit用于读模式，用它来标记可读的最大范围，capacity是最大的可写范围阈值  当我们写数据写了四个格子时，我们执行flip()方法，即可转变为读模式，limit指针就直接变到了我们刚刚写数据的极限位置，position指针回到初始位置，这样我们就可以将数据读出来了 1.2.2 读模式到写模式的两种切换  当我们将数据全部读完时，切换到写模式 调用clear()方法，它会使position指针回到初始位置，limit回到最远端，这样就可以重新开始数据了，虽然clear意为清除，但是其实它只是将指针的位置移动了，并没有将数据清除，而是会覆盖原来的位置  只读了部分数据，我想将未读的部分保留，而现在我又要开始先进行写模式的操作了，这样可以执行compact()方法 这个方法会将没有读到的数据保存到初始位置，而position指针的位置将会移动到这些数据的后面位置，从未读的数据后开始进行写数据 之后再读数据的时候，我们就能将上次没有读到的数据读出来了  1.3 Channel简介 Channel间的数据交换，都需要依赖Buffer 1.3.1 几个重要的Channel  FileChannel：用于文件传输 ServerSocketChannel和SocketChannel：用于网络编程的传输  2. 文件拷贝实战  一个字节一个字节的拷贝实在是慢的不行。  import java.io.*; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; interface FileCopyRunner{ void copyFile(File source,File target); } public class FileCopyDemo { private static void close(Closeable closeable){ if(closeable != null) { try { closeable.</description>
    </item>
    
    <item>
      <title>BIO blocking model</title>
      <link>https://kayleh.top/bio%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 04 Dec 2020 01:46:43 +0800</pubDate>
      
      <guid>https://kayleh.top/bio%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B/</guid>
      <description>BIO阻塞模型 1. BIO阻塞模型 简述BIO模型中服务端与客户端的响应过程
 服务器serverSocket先要和端口进行绑定 绑定完成后，执行accept方法，等待客户端的连接，这个方法是阻塞式调用，也就是说，要一直等待客户端的连接响应，不做其他事情，一直等，（被阻塞的还有InputStream.read()、OutputStream.write()，这两个也会一直等待客户端的响应） 客户端创建Socket对象，绑定服务器的ip地址与端口号，与服务器进行连接 服务器接收到客户端的连接请求，accept方法获取到客户端的socket信息，连接成功 服务器与客户端创建各自的io流，实现全双工通信 之后便可以随时结束连接   2. 简单实战演示 2.1 服务器 import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class Server { public static void main(String[] args) { final int DEFAULT_PORT = 8888; final String QUIT = &amp;#34;quit&amp;#34;; ServerSocket serverSocket = null; try { //绑定端口号  serverSocket = new ServerSocket(DEFAULT_PORT); System.out.println(&amp;#34;服务器已经启动，绑定端口号：&amp;#34; + DEFAULT_PORT); while (true){ //等待客户端的连接  Socket socket = serverSocket.accept(); System.out.println(&amp;#34;客户端&amp;#34; + socket.getPort() + &amp;#34;:&amp;#34; + &amp;#34;已经连接&amp;#34;); //获取io流  BufferedReader reader = new BufferedReader( new InputStreamReader(socket.</description>
    </item>
    
    <item>
      <title>I/O model</title>
      <link>https://kayleh.top/i-o%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 04 Dec 2020 01:44:24 +0800</pubDate>
      
      <guid>https://kayleh.top/i-o%E6%A8%A1%E5%9E%8B/</guid>
      <description>I/O模型 1. java.io下的字符流和字节流 1.1 字符流 字符流更加的方便我们使用，一般字符都是由多个字节来形成的，若我们使用字节流传输，则还需要我们自己将其转换为字符，若我们直接使用字符流的话，这样就能直接读取与输出字符。  CharArrayReader：是基础的字符输入流，能从字符数组中读取数据 StringReader：从字符串输入流中读取数据 输出流同理  1.1.1 更高级的字符流  BufferedReader：附带缓存区的字符输入流，但是我们并不能直接实例化供我们使用，而是将我们已经创建的Reader字符流，传入进来，就像对它升级一样，多了更多的功能，比如该字符流就是提供了缓存区，这样加快了io的效率，不必重复读取原始数据源 FilterReader：同样也是运用了装饰模式，它额外的功能能对字符流中的字符进行筛选等 InputStreamReader：连接字节流与字符流的一个桥梁，将字节流转化为字符流，比较常用的就是FileReader  1.2 字节流 字节流则是对一个个字节进行读取  ByteArrayInputStream：字节数组输入流，从字节数组中获取数据 FileInputStream：文件输入流，从文件中获取数据 输出流同理  1.2.1 更高级的字节流  BufferedInputStream：附带缓存区的字节输入流，它同样也是与BufferedReader一个原理，也需要传入进本的InputStream进行升级 DataInputStream与DataOutputStream：这俩就比较有意思了，相辅相成，与java内置的基本数据类型相关，能够将其中的字节，利用一些方法，比如toLong或toInt等方法直接转换为java的基本数据类型   2. 装饰器模式 我们刚刚看到的，在字符流中BufferedReader、InputStreamReader和FilterReader，字节流中的BufferedInputStream、DataInputStreamReader与DataOutputStream都运用到了装饰器模式，因为它们本身不能进行实例化，都需要传入基本的Reader或InputStream来进行升级，这里便体现的是装饰器模式。
 3. Socket  我们可以将Socket认为是网络传输的端点，它也是一种数据源，将特定的ip地址与端口号与其进行绑定，这样它就能够实现通信的功能，如下图中，服务器中的socket绑定了对应的ip与端口号，与客户端间进行通信   3.1 通过Socket发送数据  创建Socket，绑定特定的ip地址与端口号 将Socket与网卡驱动程序绑定 通过Socket我们就能够发送数据了 网卡驱动程序对Socket数据进行读取  3.2 通过Socket读取数据  与发送数据类似，只不过是将这个过程反过来了   我们还是要先创建Socket 将Socket与网卡驱动程序进行绑定 Socket接收来自网卡驱动程序的数据 从Socket中读取数据   4. 同步异步与阻塞非阻塞的概念 它们有两两组合的四种不同的排列组合，同步与异步强调通信机制，通俗点儿说可以是关于反应者的概念；阻塞与非阻塞强调调用状态，我们可以将其理解为调用者或者请求发起者 4.1 同步（女孩） 男孩向女孩表白，女孩立即对该事件进行思考、反应，这就是同步通信机制
4.2 异步（女孩） 异步通信机制就是，女孩不会对男孩的请求立即响应，而是女孩先去考虑考虑，有结果了呢，我发短信给你</description>
    </item>
    
    <item>
      <title>Java network programming</title>
      <link>https://kayleh.top/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 04 Dec 2020 01:35:35 +0800</pubDate>
      
      <guid>https://kayleh.top/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>@来源CSDN：方圆 1. URL地址的构造和解析 我们看如上地址，一般情况下.root根域名的部分会被省略。而URL的解析过程就是从右向左进行解析，将地址转换为IP地址，进行访问。
1.1 域名的层级 1.2 域名DNS查询的两种方式 1.2.1 递归查询  如图上所示，浏览器将请求发送给DNS客户端，客户端请求根域名服务器对域名进行解析，解析完成后，随后再访问顶级域名服务器，请求它对域名进行解析，以此类推，直至全部解析完毕，重新从三级域名服务器一层一层传递给DNS客户端，再发送给浏览器。  1.2.2 迭代查询  迭代查询是访问DNS客户端后，先访问根域名服务器，将根域名服务器中存储的该域名的内容全部发送给DNS客户端，如果无法实现域名解析的话，DNS客户端会再次请求顶级域名服务器，过程也同上，最终完成解析后，再将请求结果传递给浏览器。   Tip: 在对域名进行解析过一次后，就会产生它的缓存，存在DNS客户端中，当再次访问该域名时，就不会再去请求各个域名服务器了。对于根域名服务器，在全球是限量的，它已经被内置在DNS客户端中了，不必担心不知道根域名服务器地址的问题。
  2. 网络协议的基础知识 2.1 分层及协议  应用层：规定应用程序的数据格式 传输层：端口之间的连接 网络层：主机之间的连接，能够实现具体的定位 链路层：网卡之间的连接，每个网卡都有自己的MAC地址，在网卡生产出来的时候就已经确定了；假如通过MAC地址传递数据，那么它会给所有子网络主机都发送一份数据，并在接收时将MAC地址进行核对，一致时才进行接受，不能实现准确的定位 实体层：解决的是计算机之间的连接，一般通过光缆进行连接  2.2 各层的数据包格式 从应用层向下，每经过一层都会被添加上该层的标头，对于Ethernet标头，它的大小为18个字节，其余数据部分为1500字节，它的大小最大为1518字节，即每个帧的字节，当发送较大的文件时，就会发送多个帧的数据包，通过标头信息，在接收时能够将其组合，实现数据的正确发送。</description>
    </item>
    
    <item>
      <title>ubuntu fixed IP setting method</title>
      <link>https://kayleh.top/ubuntu%E5%9B%BA%E5%AE%9Aip%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 13 Nov 2020 23:23:35 +0800</pubDate>
      
      <guid>https://kayleh.top/ubuntu%E5%9B%BA%E5%AE%9Aip%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/</guid>
      <description>ubuntu固定IP设置方法 确认你要修改的网卡号 先确认你要修改的网卡号，假设你的服务器有多张网卡：
`ubuntu1804:~$ ip addr` 我的服务器配置如下：
`1: lo: mtu 65536 qdisc noqueue state UNKNOWN ``group` `default` `qlen 1000``link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00``inet 127.0.0.1/8 scope host lo``valid_lft forever preferred_lft forever``inet6 ::1/128 scope host``valid_lft forever preferred_lft forever``2: ens33: mtu 1500 qdisc fq_codel state UP ``group` `default` `qlen 1000``link/ether 00:0c:29:f1:b5:e1 brd ff:ff:ff:ff:ff:ff``inet 172.16.87.140/24 brd 172.16.87.255 scope global dynamic ens33``valid_lft 1500sec preferred_lft 1500sec``inet6 fe80::20c:29ff:fef1:b5e1/64 scope link``valid_lft forever preferred_lft forever` 3. 默认的网卡配置文件 默认情况下，网络使用DHCP
`ubuntu1804:~$ cat /etc/netplan/50-cloud-init.</description>
    </item>
    
    <item>
      <title>Java高性能高并发秒杀系统(10)</title>
      <link>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-10/</link>
      <pubDate>Wed, 11 Nov 2020 20:15:45 +0800</pubDate>
      
      <guid>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-10/</guid>
      <description>1. 库存预加载到Redis中是怎么实现的？ 我是通过实现InitializingBean接口，重写其中afterPropertiesSet()方法，实现的预加载
1.1 之后主动添加秒杀商品的话，怎么添加？ 通过后台管理进行添加，修改redis缓存和数据库中的值
 2. 在Redis中扣减库存的时候，是怎么保证线程安全，防止超卖的？ redis中有一个decr()方法，它实现的是递减操作，而且能够保证原子性
 3. 如果出现Redis缓存雪崩、穿透，怎么解决？ 雪崩就是缓存中我存储的值全部都失效了，请求直接打到数据库上，请求过大，数据库扛不住。可以用设置这些热点数据永不失效，或者是设置一个随机的过期时间，这样来避免它同时失效。
缓存穿透是缓存和数据库中都没有的数据，如果有人利用这些数据高并发的访问的话，对数据库压力也很大。可以对数据比如它的id值进行一个校验，避免这些不存在的值对数据库进行访问或者是使用布隆过滤器，它的原理是通过高效的数据结构查询数据库中是否存在这个值，不存在的时候，就直接返回，存在的话才会访问到数据库。
 4. 限流防刷是怎么实现的？ 限流防刷我是通过拦截器来实现的，我自定义了一个注解，它实现的功能就是标记在方法上，规定它单位时间内的访问次数，如果超过要求的话，就会被拦截。
拦截器我是继承的HandlerInterceptorAdapter，重写的是preHandle方法，在该方法中，将访问次数同步到Redis中，这个键值对是存在有效期的。最后还要把拦截器配置到项目中，继承WebMvcConfigurerAdapter，重写addInterceptors()方法
 5. 对于用户的恶意下单，他知道了你的URL地址，不停的刷，怎么办？ 我是通过隐藏URL地址来避免这种问题的，当访问秒杀接口的时候，会先从后端生成一个随机的字符串，然后保存到redis中，并且拼接到URL地址上，这样再去访问秒杀的接口，通过RestFul风格的地址，获取其中的随机字符串，与redis中的进行比对，一致的话，才能继续向下访问
 6. 秒杀成功后是怎么同步到数据库中的？ 通过两步，一步是减少商品库存，第二步是创建秒杀订单。
6.1 减库存成功，创建秒杀订单失败了怎么办？ 这两步过程在一个事务中执行，然后先减少库存，它有一个成功的标志，减少库存成功了，才去执行创建订单的操作
6.2 Spring默认的事务隔离级别 默认情况下Spring使用的是数据库设置的默认隔离级别，应该是可重复读
 7. RabbitMQ怎么提高消息的高可用？ 我在创建队列实例的时候，将其创建为可持久化的，它有一个durable属性设置为true，这样，RabbitMQ服务重启的情况下，也不会丢失消息。
 8. 说说volatile关键字儿 它最重要的一点就是保证了变量的可见性。我想先说说JMM（java内存模型），每个线程有自己的工作内存，另外还存在一个主内存，线程从主内存中获取值存储在自己的工作内存中，当对变量进行修改，它不会立即将其同步到主内中，这个时候若有其他线程来从主内存中获取该变量的时候，就会发生脏读的现象，若被volatile标记的话，就能保证变量的可见性，当变量被修改的时候他就会将其立即同步到主内存中。
 9. TCP和UDP的区别  TCP是需要通过三次握手建立连接的；UDP是无连接的 TCP提供的可靠性高；UDP的不保证可靠性，一般用于直播或者是语音通话 TCP是基于字节流的传输层协议，它比较慢；UDP比较快   10. ArrayList  底层是数组，查询快，增删慢 它的默认大小是10，添加值的时候会先对当前数组大小和总大小进行判断，若出现超过最大容量的话，就要进行扩容，扩容的大小是原来大小的1.5倍（右移运算符，右移1位），再将之前的数据复制到新的数组里边。  </description>
    </item>
    
    <item>
      <title>Java高性能高并发秒杀系统(9)</title>
      <link>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-8/</link>
      <pubDate>Mon, 09 Nov 2020 20:14:45 +0800</pubDate>
      
      <guid>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-8/</guid>
      <description>1. 动态秒杀地址 1.1 前端的改变 之前我们实现秒杀的时候是直接跳转到秒杀接口，使得我们每次的秒杀地址都是一样的，这样具有安全隐患，所以，我们将其改为动态地址，通过在前端上写一个方法进行跳转，如下所示。
 它会先跳转到/miaosha/path，获取秒杀地址中的path值，将其存储在Redis中 然后携带path值去访问真正的秒杀方法，在其中将path值与Redis中的值进行比较，一致才能继续秒杀   1.2 获取路径的Java代码 @ResponseBody @RequestMapping(value = &amp;#34;/path&amp;#34;,method = RequestMethod.GET) public Result&amp;lt;String&amp;gt; getMiaoshaPath(MiaoShaUser user,@RequestParam(&amp;#34;goodsId&amp;#34;)long goodsId, @RequestParam(value = &amp;#34;verifyCode&amp;#34;,defaultValue = &amp;#34;0&amp;#34;)int verifyCode){ if(user == null) return Result.error(CodeMsg.SESSION_ERROR); String path = miaoshaService.createMiaoshaPath(user,goodsId); return Result.success(path); } 123456789101112  先调用createMiaoshaPath()方法，在其中会创建一串随机值，并且存储到Redis中，具体方法如下，执行完之后将路径值返回到前端  public String createMiaoshaPath(MiaoShaUser user, long goodsId) { if(user == null || goodsId &amp;lt;= 0) return null; String str = MD5Util.md5(UUIDUtil.getUUID()); redisService.set(MiaoshaKey.miaoshaPathPrefix,user.getId() + &amp;#34;_&amp;#34; + goodsId,str); return str; } 123456789 1.</description>
    </item>
    
    <item>
      <title>Java高性能高并发秒杀系统(8)</title>
      <link>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-7/</link>
      <pubDate>Mon, 09 Nov 2020 20:12:45 +0800</pubDate>
      
      <guid>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-7/</guid>
      <description>1. 秒杀接口优化思路  重点我们是要减少对数据库的访问
  系统初始化时，将秒杀商品库存加载到Redis中 收到请求，在Redis中预减库存，库存不足时，直接返回秒杀失败 秒杀成功，将订单压入消息队列，返回前端消息“排队中”（像12306的买票） 消息出队，生成订单，减少库存 客户端在以上过程执行过程中，将一直轮询是否秒杀成功   2. 清晰框图解析  3. 代码中我们如何实现 3.1 库存预加载到Redis中 这里我们是通过实现InitialzingBean接口，重写其中afterProperties方法达成的
public class MiaoshaController implements InitializingBean { @Override public void afterPropertiesSet() throws Exception { //系统启动的时候，就将数据存入Redis  //加载所有秒杀商品  List&amp;lt;GoodsVo&amp;gt; goodsVos = goodsService.listGoodsVo(); if(goodsVos == null) return; //存入Redis中，各秒杀商品的数量  for (GoodsVo good : goodsVos){ redisService.set(GoodsKey.miaoshaGoodsStockPrefix,&amp;#34;&amp;#34;+good.getId(),good.getStockCount()); map.put(good.getId(),false); } } ...... } 12345678910111213141516171819  我们先从数据库中将秒杀商品的信息读取出来，再一个一个加载到缓存中 注意一下其中有一个map，它添加了对应Id-false的键值对，它表示的是该商品没有被秒杀完，用于下文中，当商品秒杀完，阻止其对redis服务的访问（后文还会提到）  3.2 开始秒杀，预减库存 //user不能为空，空了去登陆  if(user == null){ return Result.</description>
    </item>
    
    <item>
      <title>Java高性能高并发秒杀系统(7)</title>
      <link>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-6/</link>
      <pubDate>Sun, 08 Nov 2020 20:17:45 +0800</pubDate>
      
      <guid>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-6/</guid>
      <description>1. 集成RabbitMQ 1.1 添加依赖 1.2 添加配置信息  2. 进行简单测试（Direct Exchange）  任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue  2.1 创建一个配置类 @Configuration public class MQConfig { public static final String QUEUE_NAME = &amp;#34;queue&amp;#34;; @Bean public Queue queue(){ return new Queue(QUEUE_NAME,true); } } 12345678910 2.1.1 @Bean注解  @Bean注解就是要告诉方法，产生一个Bean对象，并将这个Bean由Spring容器管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Bean将放在IOC容器中。 SpringIOC容器管理一个或者多个Bean，这些Bean都需要在@Configuration注解下进行创建  2.2 创建消息的接受器 @Service @Slf4j public class MQReceiver { @RabbitListener(queues = MQConfig.QUEUE_NAME) public void receive(String message){ log.info(&amp;#34;receive message:&amp;#34; + message); } } 123456789 2.2.1 @RabbitListener注解  @RabbitListener，其中queues属性通过识别队列的名字来接受消息进行消费  2.</description>
    </item>
    
    <item>
      <title>Java高性能高并发秒杀系统(6)</title>
      <link>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-5/</link>
      <pubDate>Sun, 08 Nov 2020 20:14:45 +0800</pubDate>
      
      <guid>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-5/</guid>
      <description>1. 页面缓存优化 1.1 未经优化之前的代码 @RequestMapping(&amp;#34;/to_list&amp;#34;) public String toList(Model model,MiaoShaUser user){ model.addAttribute(&amp;#34;user&amp;#34;,user); List&amp;lt;GoodsVo&amp;gt; goodsVos = goodsService.listGoodsVo(); model.addAttribute(&amp;#34;goodsList&amp;#34;,goodsVos); return &amp;#34;goods_list&amp;#34;; } 1234567 1.2 优化产生的改变 @RequestMapping(value = &amp;#34;/to_list&amp;#34;,produces = &amp;#34;text/html&amp;#34;) @ResponseBody public String toList(HttpServletRequest request, HttpServletResponse response, Model model, MiaoShaUser user){ model.addAttribute(&amp;#34;user&amp;#34;,user); //在有缓存的情况下，取出缓存  String html = redisService.get(GoodsKey.goodsKeyPrefix, &amp;#34;&amp;#34;, String.class); if(! StringUtils.isEmpty(html)) return html; //在没有缓存的时候，手动渲染，添加缓存  List&amp;lt;GoodsVo&amp;gt; goodsVos = goodsService.listGoodsVo(); model.addAttribute(&amp;#34;goodsList&amp;#34;,goodsVos); IWebContext ctx = new WebContext(request,response,request.getServletContext(),request.getLocale(),model.asMap()); html = thymeleafViewResolver.getTemplateEngine().process(&amp;#34;goods_list&amp;#34;,ctx);//这里需要注入IContext  if(!StringUtils.isEmpty(html)){ redisService.set(GoodsKey.goodsKeyPrefix,&amp;#34;&amp;#34;,html); } return html; //return &amp;#34;goods_list&amp;#34;;  }  首先，我们应用缓存，一定要引入RedisService   @RequestMapping(value = “/to_list”,produces = &amp;quot;text/html&amp;quot;)produces标注了返回值的类型，必须与@ResponseBody搭配使用 手动渲染过程中，我们要注入ThymeleafViewResolver，这个是框架给我们准备好的Bean，利用它来渲染页面，其中第二个参数，需要注入IContext 在Spring5版本中，SpringWebContext已经没有了，我们需要使用WebContext来代替。它剔除了之前对ApplicationContext 过多的依赖，现在thymeleaf渲染不再过多依赖spring容器 再者，我们对Redis缓存的时间设置了60秒的限制，超过60秒过期，这个时间不宜过长。在60秒内我们看到的网页一直一样是暂且可以接受的   2.</description>
    </item>
    
    <item>
      <title>Java高性能高并发秒杀系统(5)</title>
      <link>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-4/</link>
      <pubDate>Sun, 08 Nov 2020 20:12:45 +0800</pubDate>
      
      <guid>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-4/</guid>
      <description>1. JMeter压力测试 1.1 测试过程  打开jmeter.bat  设置HTTP默认请求 编写协议和端口号  编写测试HTTP请求 因为我们已经写过默认设置，我们就可以不用编写协议和地址了，如下，只需编写请求类型和地址即可  添加聚合报告  我们即可在报告中查看压测信息 1.2 Linux top命令  top：相当于Windows下的任务管理器，可以动态显示当前进程的状况   2. 自定义配置文件JMeter压测 2.1 测试过程 与上方基本一致，不过，要在测试的请求上，添加CSV数据文件设置 读取我们自己编写的配置文件，并且标注变量名称，如此，即可开始压测。 其中配置文件信息，用英文逗号隔开  3. Redis压测 #100个并发连接，100000个请求 redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000 #存取大小为100字节的数据包 redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100 #测试set和lpush命令的QPS，其中-q为简化输出 redis-benchmark -t set,lpush -q -n 1000000 #测试单条命令的QPS redis-benchmark -n 100000 -q script load &amp;#34;redis.call(&amp;#39;set&amp;#39;,&amp;#39;foo&amp;#39;,&amp;#39;bar&amp;#39;)&amp;#34; 1234567891011  4. Linux环境下，命令行压测  在Windows目录下写好jmx文件 命令行：sh jmeter.</description>
    </item>
    
    <item>
      <title>Java高性能高并发秒杀系统(4)</title>
      <link>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-3/</link>
      <pubDate>Sat, 07 Nov 2020 20:13:45 +0800</pubDate>
      
      <guid>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-3/</guid>
      <description>1. 实现联表查询的一个小技巧 商品表和秒杀商品表是两个互相独立的表，其中的关联为goods_id，但是我要返回的对象，既想要商品表中的字段，又想要秒杀商品表中的字段，用下面这个方法，有点儿亮眼
@Data public class GoodsVo extends Goods { private Double miaoshaPrice; private Integer stockCount; private Date startDate; private Date endDate; } 1234567 创建一个GoodsVo类，继承Goods类，再将秒杀商品表中特有的字段，添加进去即可
1.1 左联表查询SQL语句  查询所有的商品  @Select(&amp;#34;select g.*,mg.stock_count,mg.miaosha_price,mg.start_date,mg.end_date from miaosha_goods mg left join goods g on mg.goods_id = g.id&amp;#34;) public List&amp;lt;GoodsVo&amp;gt; listGoodsVo(); 12  根据id获取商品  @Select(&amp;#34;select g.*,mg.stock_count,mg.miaosha_price,mg.start_date,mg.end_date from miaosha_goods mg left join goods g on mg.goods_id = g.id where mg.goods_id = #{goodId}&amp;#34;) public GoodsVo getGoodsVoByGoodsId(@Param(&amp;#34;goodId&amp;#34;)long goodId); 12 1.</description>
    </item>
    
    <item>
      <title>Java高性能高并发秒杀系统(3)</title>
      <link>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-2/</link>
      <pubDate>Sat, 07 Nov 2020 20:12:45 +0800</pubDate>
      
      <guid>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC-2/</guid>
      <description>1. 实现分布式Session 1.1 原理图解  作用：用Redis存储Session值，在Redis中通过token值来获取用户信息  1.2 每次登陆，将Session的过期时间进行修正  怎么说呢？我们的Session值固定过期时间为30min，要在每次登陆的时候，以当前时间继续顺延30分钟 我们的解决方法就是，每次登陆时，重新再添加一次Cookie，则能够完成时间延长  以下是封装addCookie()的方法
private void addCookie(HttpServletResponse response, MiaoShaUser user, String token) { //首次登陆的时候，需要将Cookie存入Redis  redisService.set(MiaoShaUserKey.getTokenPrefix,token,user); Cookie cookie = new Cookie(COOKIE_NAME_TOKEN, token); cookie.setMaxAge(MiaoShaUserKey.getTokenPrefix.expireSeconds()); //设置为根目录，则可以在整个应用范围内使用cookie  cookie.setPath(&amp;#34;/&amp;#34;); response.addCookie(cookie); } 123456789 1.3 Cookie有什么用？ 在我们这个项目中，Cookie中存储的是token值。而这个token值是和用户信息是一一绑定的，将会存储在Redis中。我们从Cookie中获取到token，从而就可以获取到用户，下面简化代码的过程，便是对这一过程的演示。
1.4 分布式Session的理解 服务器中的原生session是无法满足需求的，因为用户的请求有可能随机落入到不同的服务器中，这样的结果将会导致用户的session丢失，传统做法中有解决方案，是进行session同步，将一个服务器上的session进行同步到另一个服务器上，在一个集群中无论你访问哪个服务器都可以共享，但是这种方法有个明显缺陷，就是性能问题，传输有时延问题，其次这样每台服务器的session重复拥有，这样其内存必然受到影响，如果只有几台服务器还好，如果是十台，二十台服务器呢？这种恐怖的场景会是什么样的体验呢，我就无法得知了。
那么我们应该如何有效的解决这样的问题呢，我们可以使用传说中的token来解决，简单明了的说就是用户每次登陆的时候生成一个类似sessionId的东西（也就是所谓的token，这将是全局的唯一标识，如UUID，作用类似于（sessionId）），将其写到cookie当中传送给客户端，客户端对数据库访问过程中不断上传这个token，而我们服务端拿到这个token就可以获取用户的信息，这个道理其实在很多地方是相通的，比如我们容器中实现原生session，也是将生成的id写入cookie当中。
 2. 解决注解获取参数造成的代码冗余 我们看一下，如下代码
@RequestMapping(&amp;#34;/to_list&amp;#34;) public String toList(Model model, @CookieValue(value = MiaoShaUserService.COOKIE_NAME_TOKEN,required = false) String cookieToken, @RequestParam(value = MiaoShaUserService.COOKIE_NAME_TOKEN,required = false) String paramToken, ){ if(StringUtils.</description>
    </item>
    
    <item>
      <title>Java高性能高并发秒杀系统(2)</title>
      <link>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC/</link>
      <pubDate>Fri, 06 Nov 2020 20:13:45 +0800</pubDate>
      
      <guid>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E5%89%AF%E6%9C%AC/</guid>
      <description>1. 登录过程中，密码两次MD5加密 1.1 为啥用两次MD5哇？  第一次MD5，是针对传输安全做的MD5加密，因为http是明文传递，如果不进行加密的话，密码就直接被劫持了。 (Password1 = MD5(inputPassword,固定的salt值)，salt为字符串) 第二次MD5，是针对数据库安全做的MD5加密，保证数据库的防盗安全。若不进行二次加密，MD5值经数据库获取，可直接被MD5转换器直接转换为用户密码，不安全。 (Password2 = MD5(Password1,随机的salt值))   2. 构建数据库表 2.1 几个需要注意的点  字符集采用的是utf8mb4(most bytes 4)。简单来说，utf8mb4是utf8的超集，能够用4个字节存储更多的字符。标准UTF-8字符集编码可以用1~4个字节取编码21位字符，但是在MySQL中，utf8最多使用3个字节，像一些表情emoji和不常用的字符如“墅”需要用4个字节才能表示出来。用utf8mb4能解决以上问题。 数据库中存储了&amp;quot;动态&amp;quot;salt值   3. 针对MD5加密功能，封装了专用工具类 以下MD5包的Maven依赖了解以下
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;commons-codec&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-codec&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.6&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 123456789 3.1 工具类代码 public class MD5Util { //静态的salt，用于第一次MD5  private static final String salt = &amp;#34;1a2b3c4d&amp;#34;; private static String md5(String src){ //调用DigestUtils，实现md5处理  return DigestUtils.md5Hex(src); } /** * 第一次MD5处理 * @param inputPass * @return */ public static String inputPassToFormPass(String inputPass){ //这里没加“”出现了问题？？？  String pass =&amp;#34;&amp;#34; + salt.</description>
    </item>
    
    <item>
      <title>Java高性能高并发秒杀系统</title>
      <link>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Fri, 06 Nov 2020 20:12:45 +0800</pubDate>
      
      <guid>https://kayleh.top/java%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/</guid>
      <description>@CSDN方 圆 1. 集成Mybatis  我觉得在集成Mybatis时问题并不大
 1.1 新接触的不用xml文件写Mapper文件 @Mapper @Component public interface UserMapper { @Select(&amp;#34;select * from user where id = #{id}&amp;#34;) User selectById(@Param(&amp;#34;id&amp;#34;) int id); @Insert(&amp;#34;insert into user (id,name) values (#{id},#{name})&amp;#34;) int insertUser(User user); }  注解@Mapper，标记该类是一个Mapper 通常之前做练习写数据库的CRUD都是在xml文件中进行的，这次采用的是在对应的方法上标注注解的形式，@Select @Insert  1.2 事务的测试 @Service public class UserService { ... @Transactional public boolean tx(){ User user1 = new User(2,&amp;#34;222&amp;#34;); userMapper.insertUser(user1); User user2 = new User(3,&amp;#34;333&amp;#34;); userMapper.insertUser(user2); return true; } }  在UserService中，创建了一个方法，用来测试事务，用@Transactional标记  1.</description>
    </item>
    
    <item>
      <title>file input and output</title>
      <link>https://kayleh.top/10.file-input-and-output/</link>
      <pubDate>Wed, 04 Nov 2020 02:24:07 +0800</pubDate>
      
      <guid>https://kayleh.top/10.file-input-and-output/</guid>
      <description>对文件的输入输出 文件  程序文件。包括源程序文件，这种文件的内容是程序代码 数据文件。供程序运行时读写的数据  操作系统把各种设备都统一作为文件来处理。
文件一般指存储在外部介质上数据的集合。
流(数据流) 数据的输入输出.流表示了信息从源到目的地的流动.
文件名 文件路径+文件名主干+文件后缀
文件的分类  ASCII文件,在存储前需要转换,文本文件 二进制文件,存储在内存的数据的映象,不需要加以转换输出到外存,称为映像文件.  文件缓冲区 ANSI C标准采用“缓冲文件系统”处理数据文件。
所谓缓冲文件系统是指系统自动地在内存区为程序中每一个正在使用的文件开辟一个文件缓冲区从内存向磁盘输出数据必须先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘去。
如果从磁盘向计算机读入数据，则一次从磁盘文件将一批数据输入到内存缓冲区(充满缓冲区)，然后再从缓冲区逐个地将数据送到程序数据区(给程序变量) 。
程序与磁盘之间交互，不是立即完成，系统或程序可根据需要设置缓冲区，以提高存取效率
文件类型指针 对于操作系统而言,关键的概念是”文件指针”.每个被使用的文件都在内存中开辟一段存储单元,用来存放文件的有关信息.这些信息是保存在一个结构体变量中的.该结构体类型变量是由系统定义的,取名为FILE.有几个文件就建立几个这样的结构体变量,分别存放各文件的有关信息.同时返回对应的FILE结构指针.
FILE结构体类型在stdio.h文件中定义如下:
Typedef struct { short level; //缓冲区”满”或”空”的程度//  unsigned flags; //文件状态标志//  char fd; //文件描述符//  unsigned char hold; //如无缓冲区不读取字符//  short bsize; //缓冲区大小//  unsigned char *buffer; //数据缓冲区的位置//  unsigned char *curp; //指针,当前指向//  unsigned istemp; //临时文件,指示器//  short token; //用于有效性检查// }FILE; 定义一个指向文件型数据的指针变量</description>
    </item>
    
    <item>
      <title>Good use of pointers</title>
      <link>https://kayleh.top/good-use-of-pointers/</link>
      <pubDate>Mon, 26 Oct 2020 01:18:07 +0800</pubDate>
      
      <guid>https://kayleh.top/good-use-of-pointers/</guid>
      <description>善于利用指针  Good use of pointers
 指针 如果在程序中定义了一个变量，在对程序进行编译时，系统就会给这个变量分配内存单元。编译系统根据程序中定义的变量类型，分配一定长度的空间。
每一个字节都有一个编号，就是“地址”。
 地址指向该变量单元.地址形象化地称为&amp;quot;指针&amp;quot;,它能找到以它为地址的内存单元.
 c语言中的地址包括位置信息(内存编号,或称为纯地址)和它指向的数据的类型信息,或者说它是&amp;quot;带类型的地址&amp;quot;.
在程序中一般通过变量名来引用变量的值,
printf(&amp;#34;%d\n&amp;#34;,i);  对变量的访问都是通过地址进行的.
 假如有输入语句:
scanf(&amp;#34;%d&amp;#34;,&amp;amp;i); 在执行时,把键盘输入的值送到地址为2000开始的整型存储单元中.
如果有语句:
k=i+j; 则从2000~2003字节取出i的值(3),再从2004~2007字节取出j的值(6),将它们相加后再将其和(9)送到k所占用的2008~2011字节单元中.这种直接按变量名进行的访问称为&amp;quot;直接访问&amp;quot;
还可以采用另一种称为“间接访问”的方式，即将变量i的地址存放在另一变量中，然后通过该变量来找到变量i的地址。从而访问i变量。
 为了表示将数值3送到变量中，可以有两种表达方式：
  将3直接送到变量i所标识的单元中,例如&amp;quot;i=3;&amp;quot;
  将3送到变量i_pointer所指向的单元(即变量i的存储单元)，例如“i_pointer=3;”,其中**i_pointer表示i_pointer*所指向的对象，
   指向 通过i_pointer能知道i的地址，从而找到变量i的内存单元。
i_pointer指向i
 指针变量 通过指针变量访问整型变量. #include&amp;lt;stdio.h&amp;gt; int main() { int a = 100, b = 10; //定义整型变量a,b,并初始  int *point_1, *point_2; //定义指向整型数据的指针变量point_1,point_2  point_1 = &amp;amp;a; //把变量a的地址赋给指针变量point_1  point_2 = &amp;amp;b; printf(&amp;#34;a=%d,b=%d\n&amp;#34;, a, b); printf(&amp;#34;*point_1=%d,*point_2=%d\n&amp;#34;, *point_1, *point_2); return 0; } ----- a=100,b=10 *point_1=100,*point_2=10 怎么定义指针变量 类型名	* 指针变量名 指针变量是基本数据类型派生出来的类型,它不能离开基本类型而独立存在.</description>
    </item>
    
    <item>
      <title>users create data types themselves</title>
      <link>https://kayleh.top/9.users-create-data-types-themselves/</link>
      <pubDate>Mon, 26 Oct 2020 01:18:07 +0800</pubDate>
      
      <guid>https://kayleh.top/9.users-create-data-types-themselves/</guid>
      <description>用户自己建立数据类型 定义和使用结构体变量 由不同类型数据组成的组合型的数据结构，它称为结构体.
struct Student { int num; char name[20]; char sex; int age; float score; char addr[30]; }; 声明结构体类型的一般形式
struct 结构体名 {成员表列}; 结构体成员: 类型名 成员名; 成员可以属于另一个结构体类型
struct Date{ int month; int day; int year; } struct Student { struct Date birthday; //成员birthday属于struct Date类型 } 定义结构体类型变量 先声明结构体类型,再定义该类型的变量. struct Student student1,student2; 在声明类型的同时定义变量 struct Student { int num; char name[20]; char sex; int age; float score; char addr[30]; } student1, student2; struct 结构体名 { 成员表列 }变量名表列; 不指定类型名而直接定义结构体类型变量 struct { 成员表列 }变量名表列; 没有名字.</description>
    </item>
    
    <item>
      <title>realize modular programming with functions</title>
      <link>https://kayleh.top/realize-modular-programming-with-functions/</link>
      <pubDate>Mon, 26 Oct 2020 01:17:42 +0800</pubDate>
      
      <guid>https://kayleh.top/realize-modular-programming-with-functions/</guid>
      <description>用函数实现模块化程序设计  Realize modular programming with functions
 用函数输出以下结果：
***************** How do you do! ***************** #include&amp;lt;stdio.h&amp;gt; int main() { void print_star();//函数的声明  void print_message();//函数的声明  print_star(); print_message(); print_star(); return 0; } void print_star() { printf(&amp;#34;*****************\n&amp;#34;); } void print_message() { printf(&amp;#34;How do you do!\n&amp;#34;); }  函数声明的作用是把有关函数的信息(函数名,函数类型,函数参数的个数与类型)通知编译系统,以便在编译系统对程序进行编译时,在进行到main函数调用print_star()和print_message()时知道它们是函数而不是变量或其他对象,还对调用函数的正确性进行检查.
函数间可以互相调用,但不能调用main函数,main函数是被操作系统调用的.
函数从用户使用的角度看分为:
 库函数 用户自己定义的函数  从函数形式分为:
 无参函数 有参函数   怎么定义函数 定义函数应包括哪些内容:
 函数的名字,方便按名调用 函数的类型,即函数返回值的类型 函数的参数的名字和类型,调用函数时需要传递的数据 函数的功能,函数体  定义无参函数 类型名	函数名() { 函数体 } 或 类型名	函数名(void) { 函数体 } 函数体包括声明部分(变量)和语句部分.</description>
    </item>
    
    <item>
      <title>use-arrays-to-process-batch-data</title>
      <link>https://kayleh.top/use-arrays-to-process-batch-data/</link>
      <pubDate>Mon, 26 Oct 2020 01:17:20 +0800</pubDate>
      
      <guid>https://kayleh.top/use-arrays-to-process-batch-data/</guid>
      <description>利用数组处理批量数据  use-arrays-to-process-batch-data
 1.数组使一组有序数据的集合.
2.用一个数组名和下标来唯一地确定数组中的元素
3.数组中的每一个元素都属于同一个数据类型
怎样定义和引用一维数组  类型符 数组名[常量表达式]
 怎么引用一维数组元素  数组名[下标]
 对10个数组元素依次赋值为0,1,2,3,4,5,6,7,8,9,要求按逆序输出.
#include&amp;lt;stdio.h&amp;gt; int main() { int i, a[10]; for (i = 0; i &amp;lt;= 9; i++) { a[i] = i; } for (i = 9; i &amp;gt;= 0; i--) { printf(&amp;#34;%d &amp;#34;, a[i]); } return 0; } 一维数组的初始化 1)在定义数组时对全部数组元素赋予初值.
2)可以只给数组中的一部分元素赋值(只给前n个元素赋值,其余的元素自动赋值为0)
3)如果想使一个数组中全部元素值为0,可以写成
int a[10]={0}; 4)在对全部元素赋值时,如果数据的个数已经确定,因此可以不指定数组长度.
用数组来处理求Fibonacci数列问题 #include&amp;lt;stdio.h&amp;gt; int main() { int i; int f[20] = {1, 1}; for (i = 2; i &amp;lt; 20; i++) { f[i] = f[i - 2] + f[i - 1]; } for (i = 0; i &amp;lt; 20; i++) { if (i % 5 == 0) printf(&amp;#34;\n&amp;#34;); printf(&amp;#34;%12d&amp;#34;, f[i]); } printf(&amp;#34;\n&amp;#34;); return 0; } 有10个地区的面积,要求对它们按由小到大的顺序排列(冒泡排序) #include&amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>cycle structure programming</title>
      <link>https://kayleh.top/cycle-structure-programming/</link>
      <pubDate>Mon, 26 Oct 2020 01:16:57 +0800</pubDate>
      
      <guid>https://kayleh.top/cycle-structure-programming/</guid>
      <description>循环结构体程序设计 用while语句实现循环  while (表达式) 语句
 求1+2+3+&amp;hellip;.+100; #include&amp;lt;stdio.h&amp;gt; int main() { int i = 1; int sum = 0; while (i &amp;lt;= 100) { sum += i; i++; } printf(&amp;#34;%d&amp;#34;, sum); return 0; } 用do&amp;hellip;while语句实现循环  do
​	语句
while (表达式);
 如:
#include&amp;lt;stdio.h&amp;gt; int main() { int i = 1; do { printf(&amp;#34;%d\n&amp;#34;, i++); } while (i &amp;lt;= 100); return 0; } 求1+2+3+&amp;hellip;.+100; #include&amp;lt;stdio.h&amp;gt; int main() { int i = 1,sum = 0; do { sum += i; i++; } while (i &amp;lt;= 100); printf(&amp;#34;%d&amp;#34;, sum); return 0; } while和do&amp;hellip;while的区别 do&amp;hellip;while无论如何都会至少执行一次循环体</description>
    </item>
    
    <item>
      <title>select structure programming</title>
      <link>https://kayleh.top/select-structure-programming/</link>
      <pubDate>Mon, 26 Oct 2020 01:16:20 +0800</pubDate>
      
      <guid>https://kayleh.top/select-structure-programming/</guid>
      <description>选择结构程序设计 选择结构和条件判断 用if语句实现选择结构  if
 关系运算符和关系表达式    关系运算符 描述 实例     == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 为假。   != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。   &amp;gt; 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A &amp;gt; B) 为假。   &amp;lt; 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A &amp;lt; B) 为真。   &amp;gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A &amp;gt;= B) 为假。   &amp;lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A &amp;lt;= B) 为真。    输入两个实数,按由小到大的顺序输出这两个数 #include&amp;lt;stdio.h&amp;gt; int main() { float a, b, t; scanf(&amp;#34;%f,%f&amp;#34;, &amp;amp;a, &amp;amp;b); if (a &amp;gt; b) { //将a和b的值互换  t = a; a = b; b = t; } printf(&amp;#34;%5.</description>
    </item>
    
    <item>
      <title>sequential programming</title>
      <link>https://kayleh.top/sequential-programming/</link>
      <pubDate>Mon, 26 Oct 2020 01:16:00 +0800</pubDate>
      
      <guid>https://kayleh.top/sequential-programming/</guid>
      <description>顺序程序设计 求摄氏度
#include&amp;lt;stdio.h&amp;gt; int main() { float f, c; f = 64.0; c = (5.0 / 9) * (f - 32); printf(&amp;#34;f=%f\nc=%f\n&amp;#34;, f, c); return 0; } 常量   整型常量
  实性常量(有小数点)
 十进制小数形式 指数形式:如12.34e3(e或E之前必须有数字,e或E之后必须为整数)    字符常量
 普通字符,用单撇号括起来的一个字符   字符常量存储在计算机存储单元中时,并不是存储字符本身,而是以其代码(一般采用ASCII码)存储的
  转义字符    字符串常量
   用双撇号括起来的全部字符,双撇号内可以只有一个字符
  符号常量  用#define指令,指定用一个符号名称代表一个常量
 在预编译后,符号变量会全部被置换,
 #define PI 3.1415 //注意行末没有分号 变量 变量代表一个有名字,具有特定属性的一个存储单元,它用来存放数据,在程序运行期间,变量的值时可以改变的.</description>
    </item>
    
    <item>
      <title>C algorithm</title>
      <link>https://kayleh.top/c-algorithm/</link>
      <pubDate>Mon, 26 Oct 2020 01:15:22 +0800</pubDate>
      
      <guid>https://kayleh.top/c-algorithm/</guid>
      <description>算法 1.什么是算法? 算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。
2.什么叫结构化算法?为什么要提倡结构化算法? 结构化算法是由一些基本结构顺序组成的，就是把一个大的功能的实现分隔为许多个小功能的实现。
自顶向下,逐步细化,模块化设计,结构化编码</description>
    </item>
    
    <item>
      <title>C programming</title>
      <link>https://kayleh.top/c-programming/</link>
      <pubDate>Mon, 26 Oct 2020 01:14:40 +0800</pubDate>
      
      <guid>https://kayleh.top/c-programming/</guid>
      <description>程序 1.什么是程序?什么是程序设计? 程序是一组计算机能识别和执行的指令，运行于电子计算机上，满足人们某种需求的信息化工具。 程序设计（programming），是给出解决特定问题程序的过程，软件开发过程中的重要步骤。程序设计往往以某种程序设计语言为工具，给出这种语言下的程序。程序设计过程一般包括分析、设计、编码、测试、调试等不同阶段。
2.为什么需要计算机语言?高级语言有哪些特点? 人和计算机交流信息需要解决语言问题,需要创造一种计算机和人都能识别的语言.
高级语言是从人类的逻辑思维角度出发的计算机语言，抽象程度大大提高，需要经过编译成特定机器上的目标代码才能执行，一条高级语言的语句往往需要若干条机器指令来完成。高级语言独立于机器的特性是靠编译器为不同机器生成不同的目标代码(或机器指令)来实现的。
3.正确解释一下名词以及含义: (1)源程序,目标程序,可执行程序。 源程序：指未编译的按照一定的程序设计语言规范书写的文本文件，是一系列人类可读的计算机语言指令
目标程序：为源程序经编译可直接被计算机运行的机器码集合，在计算机文件上以.obj作扩展名
可执行程序：将所有编译后得到的目标模块连接装配起来，在与函数库相连接成为一个整体，生成一个可供计算机执行的目标程序，成为可执行程序
(2)程序编辑,程序编译,程序连接。 程序编辑：上机输入或者编辑源程序。
程序编译：
 先用C提供的“预处理器”，对程序中的预处理指令进行编译预处理 对源程序进行语法检查， 判断是否有语法错误，直到没有语法错误未知 编译程序自动把源程序转换为二进制形式的目标程序  程序连接：将所有编译后得到的目标模块连接装配起来，在与函数库相连接成为一个整体的过程称之为程序连接
(3)程序,程序模块,程序文件。 程序：一组计算机能识别和执行的指令，运行于电子计算机上，满足人们某种需求的信息化工具
程序模块：可由汇编程序、编译程序、装入程序或翻译程序作为一个整体来处理的一级独立的、可识别的程序指令
程序文件：程序的文件称为程序文件，程序文件存储的是程序，包括源程序和可执行程序
(4)函数,主函数，被调用函数,库函数。 函数：将一段经常需要使用的代码封装起来，在需要使用时可以直接调用，来完成一定功能
主函数：又称main函数，是程序执行的起点
被调用函数：由一个函数调用另一个函数，则称第二个函数为被调用函数
库函数：一般是指编译器提供的可在c源程序中调用的函数。可分为两类，一类是c语言标准规定的库函数，一类是
编译器特定的库函数
(5)程序调试,程序测试。 程序调试：是将编制的程序投入实际运行前，用手工或编译程序等方法进行测试，修正语法错误和逻辑错误的过程
程序测试：是指对一个完成了全部或部分功能、模块的计算机程序在正式使用前的检测，以确保该程序能按预定的
方式正确地运行
4.编写一个c程序,运行时输出 Hello World!
#include&amp;lt;stdio.h&amp;gt; int main() { printf(&amp;#34;Hello World!&amp;#34;); return 0; } 5.编写一个c程序,运行时输出一下图形 *****
​	*****
​	*****
​	*****
#include&amp;lt;stdio.h&amp;gt; int main() { printf(&amp;#34;*****\n&amp;#34;); printf(&amp;#34; *****\n&amp;#34;); printf(&amp;#34; *****\n&amp;#34;); printf(&amp;#34; *****\n&amp;#34;); return 0; } 6.</description>
    </item>
    
    <item>
      <title>ubuntu.deb安装包</title>
      <link>https://kayleh.top/ubuntu-deb%E5%AE%89%E8%A3%85%E5%8C%85/</link>
      <pubDate>Tue, 06 Oct 2020 21:16:50 +0800</pubDate>
      
      <guid>https://kayleh.top/ubuntu-deb%E5%AE%89%E8%A3%85%E5%8C%85/</guid>
      <description>dkpg -i xxxx.deb 需要超级用户权限
sudo dkpg -i xxxx.deb </description>
    </item>
    
    <item>
      <title>微分方程</title>
      <link>https://kayleh.top/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</link>
      <pubDate>Mon, 05 Oct 2020 22:55:36 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</guid>
      <description>微分方程 定义： 微分方程的阶： 导数的最高阶数
二阶：
通解 独立常数的个数=阶数，比如二阶的最终的解里有c1，c2两个独立的常数
特解 如果常数都确定的解叫特解
初始条件 解题过程 一般把初始条件代入到通解里，确定常数的值，得到的就是特解
一阶微分方程 可分离变量  分离变量，同时积分
 例题： 齐次方程 dy/dx=f(y/x)
例题 ​ ↓
一阶线性方程 一阶线性齐次微分方程：
齐次方程的解非齐次方程的解：
例题 #伯努利方程 </description>
    </item>
    
    <item>
      <title>级数</title>
      <link>https://kayleh.top/%E7%BA%A7%E6%95%B0/</link>
      <pubDate>Sun, 04 Oct 2020 13:24:36 +0800</pubDate>
      
      <guid>https://kayleh.top/%E7%BA%A7%E6%95%B0/</guid>
      <description>无穷级数 等比数列
例题
调和级数  调和级数是发散的
 性质  相反则未必
 敛散性不变
如果级数收敛，通项是趋于0的。
  通项趋于0，未必是收敛的，
  通项不趋于0，一定是不收敛的。
  例题：
通项不趋于0必发散
去掉了第一项，敛散性不变
正项级数 大收必小收 小散必大散
例题
公式
例题  等于1说明分子分母有相同的敛散性,1/n是发散的
 达朗贝尔判别法 1
2
解题过程：
任意项级数 和调和级数相比，这个是收敛的(“交错调和级数”)
例题：
证明$U^n$是递减的
绝对值级数 定理： 绝对收敛  例题：   先取绝对值，p级数是收敛的，这个就是绝对收敛的。
  取绝对值，是调和级数发散的，但是原来的是交错调和级数是收敛的，所以是条件收敛
 定理 例题：
总结 例题： 性质： </description>
    </item>
    
    <item>
      <title>二重积分</title>
      <link>https://kayleh.top/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/</link>
      <pubDate>Fri, 02 Oct 2020 14:43:15 +0800</pubDate>
      
      <guid>https://kayleh.top/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86/</guid>
      <description>概念 体积
几何含义 性质 直角坐标系的计算 例题：  x型是从左到右走
上边的函数写成上限，下边的函数写成下限
  y型是从下到上走
左边的函数写成下限，右边的函数写成上限
 特殊 矩形
分成两部分的：
极坐标的计算 极坐标
二重积分写成极坐标的表达方式 例题：
$-e^{-x}$求导是$e^{-x}$</description>
    </item>
    
    <item>
      <title>偏导数</title>
      <link>https://kayleh.top/%E5%81%8F%E5%AF%BC%E6%95%B0/</link>
      <pubDate>Wed, 30 Sep 2020 13:38:35 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%81%8F%E5%AF%BC%E6%95%B0/</guid>
      <description>在某点偏导的定义  对y求导时，是把x看作常数，对y求导
对x求导时，是把y看作常数，对x求导
 多元函数可导不连续 例题：
几何意义 二阶偏导数和混合偏导  先求x再求y跟先求y再求x时一样的
 如果两个混合二阶偏导数在区域d上是连续的。
全微分 x，y都发生的变化引起了z的变化
定义： 可微必要条件 偏导存在只是可微的必要条件。
可微的充分条件  一个全微分等于两个偏微分之和。
 例题：
多元复合函数求导  x对x求导=1
 例题： 隐函数求导 定理1 例题： 定理2： 例题 定理3 例题：
###################
克莱姆法则 二元函数的极值 </description>
    </item>
    
    <item>
      <title>多元函数</title>
      <link>https://kayleh.top/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 29 Sep 2020 01:10:02 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0/</guid>
      <description>空间解析几何 两点之间距离
平面方程 球面方程 z是正的表示求的上半部分，负的表示下半部分。
旋转抛物面：
双曲抛物面：
多元函数 邻域
开集：所有的点都是内点
闭区域：既包含内点和边界点
二元函数的极限  证明极限不存在
找两种不同的逼近方式
 例题：
求极限
连续 </description>
    </item>
    
    <item>
      <title>广义积分和瑕积分</title>
      <link>https://kayleh.top/%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86/</link>
      <pubDate>Mon, 28 Sep 2020 21:58:19 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86/</guid>
      <description>广义积分 无穷限积分 ①上限是无穷的，就对b求导
如果极限存在，就是收敛的，如果不存在，就是发散的。
②下限是无穷的，就对a求导
③上下限都是无穷
结合①和②来求。
例题： 广义的牛顿-莱布尼茨公式
总结： 性质  -也收敛
  2）第二个性质。反之，不一定
 分部积分和换元积分也成立。
收敛判定 定理：
★★★比较判别法 大敛则小敛，小散大必散
 找一个比被积函数大的易比函数进行比较
  绝对收敛、条件收敛 绝对收敛必收敛
#瑕积分 </description>
    </item>
    
    <item>
      <title>定积分</title>
      <link>https://kayleh.top/%E5%AE%9A%E7%A7%AF%E5%88%86/</link>
      <pubDate>Sat, 26 Sep 2020 20:38:49 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%AE%9A%E7%A7%AF%E5%88%86/</guid>
      <description>定积分 性质  插入分点，区间内取任意值，求任意值的函数值，$△x_n$小区间的长度
拉姆达是最大的区间
 定义 $f(x)$在$[a,b]$有界，在$[a,b]$任意插入分点
分成n个区间，△x_1,△x_2&amp;hellip;.△x_n,任取一点 $\xi_i$
$$\int_a^b{f(x)dx}=\lim_{\lambda \to 0} \sum_{i=1}^n{f(\xi_i)△x_i}$$
$$\lambda=max{△x_1&amp;hellip;△x_n}$$
注意： 两个图像都是一样的
定理 1）连续就可积
2）有界，有限个间断点，可积
几何意义 ②积分等于面积的相反数
例题 定积分的近似计算 矩形法 梯形法 抛物线法 性质 1）当b=a时，
$$\int_a^a{f(x)=0}$$
2）$$\int_a^b{f(x)dx}= - \int_b^a{f(x)dx}$$
 不管是a&amp;lt;c&amp;lt;b还是a&amp;lt;b&amp;lt;c,性质2公式都成立
 推论 性质6
定积分中值定理  f(x)必须是连续的
 在最小值和最大值之间一定能找到一点$\xi$
函数值$f(\xi)$就是平均值。
微积分的基本原理 积分上限函数 x是变化的
 定义 积分上限函数p(x)是连续的
 定理 如果f(x)在[a,b]上连续，那么p(x)在积分区域上可导
$$p&#39;(x)=f(x)$$
1)如果上限是x，直接将x代入被积函数
2)如果x是下限，取相反数，再直接将x代入被积函数
3）如果上限是x的函数g(x)
复合函数求导——链式法则
1.把上限g(x)直接代入被积函数
2.对上限求导g&#39;(x)
4）如果上限是x的函数h(x)
1.把上限h(x)直接代入被积函数
2.对上限求导h&#39;(x)
3.取相反数，加负号
5）上下都是x的函数，
可以根据积分的性质，在h(x)和g(x)之间任取一点C，求h(x)到c的积分和c到g(x)的积分。
 例题  牛顿莱布尼茨公式 例题：定积分的换元积分法 例题： 3ln3</description>
    </item>
    
    <item>
      <title>图床</title>
      <link>https://kayleh.top/%E5%9B%BE%E5%BA%8A/</link>
      <pubDate>Fri, 25 Sep 2020 20:45:24 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%9B%BE%E5%BA%8A/</guid>
      <description>原地址https://www.jianshu.com/u/e68ebf1b004c
Github repo图床 Github的repo也可以储存东西，最直接的就是程序的版本控制，当然也可以用来当作备份储存，用来储存图片（github官方回复是：该行为不构成abuse，如果把github当图床算滥用，那么那么多人把微博当图床怎么就理所应当捏）。其实github对于国内的响应速度并不快，而且时不时被block，所以用github当图床完全是出于储存个人用途的自创图片，并不能当CDN使用。github自从被微软收购后，我对github的信心大增，代码以前只敢用git管理保存在本地，现在可以放心大胆上传到github了（很多是private，所以不可见），github图床主要就是图个稳定，也并不是想恶意刷github服务器的流量，恶意影响大家的体验。
  新建repo，名称任意
  打开账户/Settings/Developer settings/Personal access tokens,点击Generate new token
image
image
  在弹出的产生token页面，Token description随意填写，但是一定要勾选上这几项
image
  下载PicGo客户端对应的版本并安装，github地址：https://github.com/Molunerfinn/PicGo/releases
  启动PicGo后，打开设置界面，点击
image
在第一栏填入你的github名称/repo名称；在第二栏填入你的分支名称，默认为master；在第三栏填入你刚才申请到的Token；第四栏填入你的repo中的储存路径；最后点击确认，再点击设为默认图床
  使用QQ截图Ctrl+Alt+A或者微信的Alt+A截图后，按下Ctrl+Shiht+P快捷键即可自动上传到github对应的repo中，上传完成后，会有提示，自动将对应的图片地址送入剪贴板中，直接Ctrl+V即可粘贴对应的地址出来了~~
  </description>
    </item>
    
    <item>
      <title>不定积分</title>
      <link>https://kayleh.top/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/</link>
      <pubDate>Wed, 23 Sep 2020 17:06:12 +0800</pubDate>
      
      <guid>https://kayleh.top/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/</guid>
      <description>$F&#39;(x)=f(x)$
$F(x)$是$f(x)$的一个原函数.
 F(x)是f(x)的一个原函数，F(x)+c也是f(x)的原函数
 $f(x)$是$F&#39;(x)$的导函数.
知道$F&#39;(x)$,$f(x)$只有唯一一个
知道$f(x)$,$F&#39;(x)$可以有无穷多个
不定积分 $f(x)$的原函数的全体
**$\int_{}{}f(x) \text{d}x$**
 $\int_{}{}$:	sum,积分符号
$x$:	积分变量
$f(x)$:	被积函数
 $\int_{}{}f(x) \text{d}x = F(x)+c$
例题  $\int_{}{}x^2 \text{d}x = \frac{1}{3}x^3+c$  几何意义 性质 $$\int_{}{}kf(x)\text{d}x=k\int_{}{}f(x)\text{d}x$$
k可以朝外拿：
①k是常数
②k是与x无关的另变量
 有限个可以，但无限个不能
 基本积分公式 例题：
积分法 第一换元积分法(凑微分法)  求原函数
 1）把d外面的某项拿到d里面(变成原函数)
2）凑基本积分公式
例题： dk()=kd()
d()里面的项可以随意加减常数
第二换元积分  求导
 公式 分部积分法 优先：
 $e^x,sinx,cosx,x(x^n),lnx,arctanx$
 有理函数积分 分子的最高次数比较高：
最高次数相等(最终使分母次数高)：
所有方法都要化成分母次数比分子次数高。
真分式 分母次数比分子次数高的叫做真分式
第一类题目 1）$b^2-4ac=0$ $ax^2+bx+c=0$</description>
    </item>
    
    <item>
      <title>函数作图</title>
      <link>https://kayleh.top/%E5%87%BD%E6%95%B0%E4%BD%9C%E5%9B%BE/</link>
      <pubDate>Wed, 23 Sep 2020 13:41:02 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%87%BD%E6%95%B0%E4%BD%9C%E5%9B%BE/</guid>
      <description>渐近线  水平、垂直、斜
 水平渐近线 例题：
垂直渐近线 斜渐近线 例题：
分子次数比分母高，取无穷
分子与分母次数一样，极限等于最高次的系数之比
微分法作图 “导数” 例如：</description>
    </item>
    
    <item>
      <title>极值和最值</title>
      <link>https://kayleh.top/%E6%9E%81%E5%80%BC%E5%92%8C%E6%9C%80%E5%80%BC/</link>
      <pubDate>Sun, 20 Sep 2020 23:04:06 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%9E%81%E5%80%BC%E5%92%8C%E6%9C%80%E5%80%BC/</guid>
      <description>极值和最值 定理： f(x)在$x_0$可导，且在$x_0$取极值。$f&#39;(x_0)=0$
证明：
求极值 例题：
定理： f(x)的二阶导数也等于0的时候，不能判断：
最值 极值是局部区域的，最值是全部区域
求最值 找到这几个点：
连续并单调的函数，最值就是端点；
在区间内的极值就是最值。</description>
    </item>
    
    <item>
      <title>函数的单调性和凸凹性</title>
      <link>https://kayleh.top/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E8%B0%83%E6%80%A7%E5%92%8C%E5%87%B8%E5%87%B9%E6%80%A7/</link>
      <pubDate>Sun, 20 Sep 2020 13:00:16 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%87%BD%E6%95%B0%E7%9A%84%E5%8D%95%E8%B0%83%E6%80%A7%E5%92%8C%E5%87%B8%E5%87%B9%E6%80%A7/</guid>
      <description>单调性 增f&#39;(x)&amp;gt;0减f&#39;(x)&amp;lt;0
f&#39;(x)≥0，等号在个别点上成立，仍然也是增函数
f&#39;(0)不存在,左右导数
凸凹性 定义：
利用拉格朗日中值定理：
例题：
求凸凹区间和拐点：
f‘’不存在：</description>
    </item>
    
    <item>
      <title>洛必达法则</title>
      <link>https://kayleh.top/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/</link>
      <pubDate>Sat, 19 Sep 2020 22:31:17 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/</guid>
      <description>洛必达法则 两种形式： $$\frac{0}{0}$$
$$\frac{\infty}{\infty}$$
$$\frac{0}{0}$$ 例题：
重要极限也可以用洛必达法则证明：
 必须是$\frac{0}{0}$型或$\frac{\infty}{\infty}$型才可以再次求导。
 $$\frac{\infty}{\infty}$$ 其实和$\frac{0}{0}$没区别：
例题：
趋于正无穷的速度：
对数&amp;lt;幂函数&amp;lt;指数函数
洛必达法则注意 1)只有$\frac{0}{0}$或$\frac{\infty}{\infty}$才用
2)不要一味求导，与重要极限、等价无穷小替换结合
3)例题：</description>
    </item>
    
    <item>
      <title>微分</title>
      <link>https://kayleh.top/%E5%BE%AE%E5%88%86/</link>
      <pubDate>Thu, 17 Sep 2020 23:39:06 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%BE%AE%E5%88%86/</guid>
      <description>微分 微分的定义： 充要条件
可微就可导，可导就可微
A就是$x_0$上的导数
$$dy=f^{&#39;}(x)△x=f^{&#39;}(x)dx$$
$△x=dx$是精确值，$△y≈dy$是近似值
导数也叫微商 ，导数定义的dy是对dx求导，可以看做一个整体：
例题： 微分的几何意义 基本公式 $dc=c&amp;rsquo;dx=0$
略
四则运算 例题： 不变性：
微分应用  近似计算
 $$f(x_0+△x)≈f(x_0)+f&#39;(x_0)△x$$ ，|△x|取很小
例题： 微分中值定理 费马定理 左导数和右导数要想相等，只能等于0
∴$f^{&#39;}(x_0)=0$
驻点： 导数为0的点就叫驻点。
罗尔定理 拉姆朗日中值定理  f(x)在区间I连续，I内可导且导数恒为0。f(x)=C
证明：
 柯西中值定理 由拉姆朗日中值定理推出：
柯西能推出拉格朗日定理，拉格朗日能推出罗尔
#泰勒定理 定理：$f(x)$表示成$x-x_0$的n次多项式+$R_n (x)$</description>
    </item>
    
    <item>
      <title>导数</title>
      <link>https://kayleh.top/%E5%AF%BC%E6%95%B0/</link>
      <pubDate>Wed, 16 Sep 2020 00:20:05 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%AF%BC%E6%95%B0/</guid>
      <description>变化率 $x_0 \to x_0+△x$.
$f(x_0) \to f(x_0+△x)$
$\frac{f(x_0+△x)-f(x_0)}{△x}$
从x_0到x_0+△x的平均变化率
导数的四个符号
导数的三种表达方式
例题：    $y=x^2$
$y&#39;$
$y&#39;|_{x=2}$
=4;
求导 导数意义 例题：
求$y=x^3$在(1,1)的切线和法线
左右导数，左右导数都存在并相等
求导法则： (1)$u(x)、v(x)$可导，$(u(x)+v(x))&#39;=u&#39;(x)+v&#39;(x)$
(2)$(uv)&#39;=u&amp;rsquo;v+uv&#39;$
(3)$\frac{u}{v}=\frac{u&amp;rsquo;v+uv&#39;}{v^2}$
反函数求导法则： $y=f(x)$ . $x=\phi(y)$
反函数=导数的倒数 $\phi(y)=\frac{1}{f&#39;(x)}$
复合函数： 链式法则： 剥洋葱解法，从外往里剥。
高阶函数 对$y$求两次导数，记作$y^{&#39;&#39;}$,二阶导数
或者$\frac{d^2y}{dx^2}$
从4阶开始用数字表示:$y^{(4)}$
例题： </description>
    </item>
    
    <item>
      <title>连续</title>
      <link>https://kayleh.top/%E8%BF%9E%E7%BB%AD/</link>
      <pubDate>Mon, 14 Sep 2020 23:53:48 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%BF%9E%E7%BB%AD/</guid>
      <description>增量(改变量) △x是自变量的增量，△y是因变量的增量
定义：
f(x)在$x_0$的邻域内有定义，$△x\to 0$,$△y\to 0$
$$\lim_{x\to 0}△y=\lim_{x\to 0} [f(x_0+△x)-f(x_0)]=0$$
&amp;amp;或者
$$\lim_{x\to x_0} f(x) = f(x_0)$$
那么就叫这个函数在这点$x_0$上是连续的
1)在$x_0$处有定义
2)$x\to x_0 f(x)$有极限
3)极限=在$x_0$处的定义，$f(x_0)$
左连续 $(x_0-\delta,x_0]$ 在x_0处连续的充要条件是既是左连续也是右连续
在区间上连续 间断点 连续的条件
1)在$x_0$处有定义
2)$x\to x_0 f(x)$有极限
3)极限=定义
  无穷间断
在$x_0$处没有定义
  振荡
$x\to x_0 f(x)$没有极限
  跳跃
左右极限不相等
  可去
  第一类间断点： 左右极限均存在，跳跃、可去间断点
第二类间断点： 左右极限不存在，无穷间断、振荡
例题： 左右极限都存在但不相等
运算法则 四则运算 $f(x)±g(x).g(x)f(x).\frac{f(x)}{g(x)} (g(x)≠0)$ 依然连续
例题：
$f(x)= e^{lnf(x)}$、两个重要极限
闭区间上连续性质 (有界性) 如果在$[a,b]$上是连续的，有界
(最值性) 如果在$[a,b]$上是连续的，b有最大最小值</description>
    </item>
    
    <item>
      <title>无穷小与无穷大</title>
      <link>https://kayleh.top/%E6%97%A0%E7%A9%B7%E5%B0%8F%E4%B8%8E%E6%97%A0%E7%A9%B7%E5%A4%A7/</link>
      <pubDate>Sat, 12 Sep 2020 16:33:41 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%97%A0%E7%A9%B7%E5%B0%8F%E4%B8%8E%E6%97%A0%E7%A9%B7%E5%A4%A7/</guid>
      <description>无穷小量 定义： 极限为0的变量称为无穷小量，简称无穷小.
f(x)→0
常用希腊字母 $\alpha$ ,$\beta$ ,$\gamma$
$$\lim_{x\to0}x^2=0 极限为0$$
$$\lim_{x\to1}x^2=1 极限为1$$
$$\lim_{x\to\infty}x^2=0 极限为\infty$$
定理: 1.无穷小 × 有界 是无穷小
另一个例题
分解后面的ardtanx，加上绝对值|ardtanx|，说明是有界的。
2.无穷大 $f(x)-&amp;gt;+\infty 或-\infty$
1)两个无穷大相乘=无穷大
2)无穷大+有界-&amp;gt;无穷大
定理：    f(x)无穷大 $\frac{1}{f(x)}$无穷小 (同一变化过程) f(x)无穷小 $\frac{1}{f(x)}$无穷小(同一变化过程)  极限的运算法则 定理(四则运算) 若$\lim f(x)=a , \lim g(x)=b$（前提是每个函数极限存在,项是有限个的）
1)$\lim (f(x)+g(x))=\lim f(x) ± \lim g(x)=a ± b$
2)$\lim f(x)g(x)=\lim f(x) · \lim g(x)$
3)$\lim \frac{f(x)}{g(x)}=\frac {\lim f(x)}{\lim g(x)}(b≠0)$
其实就是把极限带进去
$\lim f(x)^n=(\lim f(x))^n$
例如：
$\frac{\infty}{\infty}$ 分子、分母同次，最高次的系数之比（分子分母都趋于无穷）
分母次数高，0</description>
    </item>
    
    <item>
      <title>极限</title>
      <link>https://kayleh.top/%E6%9E%81%E9%99%90/</link>
      <pubDate>Sat, 12 Sep 2020 10:30:50 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%9E%81%E9%99%90/</guid>
      <description>极限  [“极限”是数学中的分支——微积分的基础概念，广义的“极限”是指“无限靠近而永远不能到达”的意思。数学中的“极限”指：某一个函数中的某一个变量，此变量在变大（或者变小）的永远变化的过程中，逐渐向某一个确定的数值A不断地逼近而“永远不能够重合到A”（“永远不能够等于A，但是取等于A‘已经足够取得高精度计算结果）的过程中，此变量的变化，被人为规定为“永远靠近而不停止”、其有一个“不断地极为靠近A点的趋势”。极限是一种“变化状态”的描述。此变量永远趋近的值A叫做“极限值”（当然也可以用其他符号表示）。
 证明：1=0.9999·····？
比如
假设有一圆
有内接圆面积$A_1$
记内接十二边形的面积为$A_2$
24边形
就可以得到一个数列{$A_n$}
数列的极限 当n→$\infty$时，{$A_n$}也无限接近于某一确定的数值，这个数值称为数列{$A_n$}当n→$\infty$时的极限。
后面的值都落在这个邻域里面
 n一定是 &amp;gt; ???
 要求 $\lvert x_n -1 \rvert$=$\frac{1}{n}$&amp;lt;$\epsilon$,只要n&amp;gt;[$\frac{1}{\epsilon} $],以后的一切项均满足 $\lvert x_n -1 \rvert$&amp;lt;$\epsilon$.
对于任意给定的正数$\epsilon$，总存在着一个正整数N(比如取N=[$\frac{1}{\epsilon}$]),当n&amp;gt;N时，
$$\lvert x_n -1 \rvert&amp;lt;\epsilon$$
记作
$$\lim_{n\to \infty} x_n = a或x_n→a(n→\infty)$$
如果上述a不存在，则称数列 $${x_n}$$没有极限,或者说数列 $${x_n}$$ 是发散的，也说 $\lim_{n\to \infty} x_n$ 不存在.
注意： 1.$\epsilon$的“任意给定”性极其重要；
2.N与$\epsilon$有关，有$\epsilon$的给定而确定；
3.$\forall$表示“任意给定”，$\exists$表示“存在”
例子： 性质 性质1：{$x_n$}收敛 ，极限唯一.
性质2：{$x_n$}收敛 ，有界
 有界是收敛的必要，不是充分条件 单调有界，则有极限  性质3：保号性$\lim_{x_n} = a$ , a&amp;gt;0(a&amp;lt;0) ,$\exists$N, n&amp;gt;N ,$x_n$&amp;gt;0</description>
    </item>
    
    <item>
      <title>值传递</title>
      <link>https://kayleh.top/%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Thu, 10 Sep 2020 13:01:12 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88/</guid>
      <description>传值调用 向函数传递参数的传值调用方法，把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。默认情况下，C++ 使用传值调用方法来传递参数。一般来说，这意味着函数内的代码不会改变用于调用函数的实际参数。
#include &amp;lt;iostream&amp;gt;using namespace std; // 函数声明 void swap(int x, int y); // 函数定义 void swap(int x, int y) { int temp; temp = x; /* 保存 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 x 赋值给 y */ return; } int main() { // 局部变量声明  int a = 100; int b = 200; cout &amp;lt;&amp;lt; &amp;#34;before swap,a:&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;before swap,b:&amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; // 调用函数来交换值  swap(a, b); cout &amp;lt;&amp;lt; &amp;#34;After swap,a:&amp;#34; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;After swap,b:&amp;#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl; return 0; }  指针调用 向函数传递参数的指针调用方法，把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</description>
    </item>
    
    <item>
      <title>docker虚拟化容器</title>
      <link>https://kayleh.top/docker%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AE%B9%E5%99%A8ing/</link>
      <pubDate>Fri, 28 Aug 2020 16:36:20 +0800</pubDate>
      
      <guid>https://kayleh.top/docker%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AE%B9%E5%99%A8ing/</guid>
      <description>&lt;p&gt;docker&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SnowFlake分布式ID雪花算法</title>
      <link>https://kayleh.top/snowflake%E5%88%86%E5%B8%83%E5%BC%8Fid%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95ing/</link>
      <pubDate>Fri, 28 Aug 2020 16:20:50 +0800</pubDate>
      
      <guid>https://kayleh.top/snowflake%E5%88%86%E5%B8%83%E5%BC%8Fid%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95ing/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Seata处理分布式事务</title>
      <link>https://kayleh.top/seata%E5%A4%84%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Wed, 26 Aug 2020 12:25:48 +0800</pubDate>
      
      <guid>https://kayleh.top/seata%E5%A4%84%E7%90%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;p&gt;Seata&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sentinel实现熔断与限流</title>
      <link>https://kayleh.top/sentinel%E5%AE%9E%E7%8E%B0%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%90%E6%B5%81/</link>
      <pubDate>Mon, 24 Aug 2020 21:18:27 +0800</pubDate>
      
      <guid>https://kayleh.top/sentinel%E5%AE%9E%E7%8E%B0%E7%86%94%E6%96%AD%E4%B8%8E%E9%99%90%E6%B5%81/</guid>
      <description>&lt;p&gt;Sentinel&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>gulp压缩静态资源</title>
      <link>https://kayleh.top/gulp%E5%8E%8B%E7%BC%A9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/</link>
      <pubDate>Mon, 24 Aug 2020 11:28:18 +0800</pubDate>
      
      <guid>https://kayleh.top/gulp%E5%8E%8B%E7%BC%A9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/</guid>
      <description>&lt;p&gt;hexo&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nacos服务注册和配置中心</title>
      <link>https://kayleh.top/nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</link>
      <pubDate>Fri, 21 Aug 2020 17:44:55 +0800</pubDate>
      
      <guid>https://kayleh.top/nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</guid>
      <description>&lt;p&gt;Nacos&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Traffic monetization:Access to Google Adsense</title>
      <link>https://kayleh.top/%E6%8E%A5%E5%85%A5%E8%B0%B7%E6%AD%8C%E5%B9%BF%E5%91%8A%E8%81%94%E7%9B%9Fadsense/</link>
      <pubDate>Fri, 21 Aug 2020 15:23:22 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%8E%A5%E5%85%A5%E8%B0%B7%E6%AD%8C%E5%B9%BF%E5%91%8A%E8%81%94%E7%9B%9Fadsense/</guid>
      <description>&lt;p&gt;流量变现: 接入谷歌广告联盟&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kayleh.top&#34;&gt;https://kayleh.top&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;</description>
    </item>
    
    <item>
      <title>中英文切换</title>
      <link>https://kayleh.top/%E4%B8%AD%E8%8B%B1%E6%96%87%E5%88%87%E6%8D%A2/</link>
      <pubDate>Fri, 21 Aug 2020 11:28:18 +0800</pubDate>
      
      <guid>https://kayleh.top/%E4%B8%AD%E8%8B%B1%E6%96%87%E5%88%87%E6%8D%A2/</guid>
      <description>&lt;p&gt;hexo&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>jsdelivr的CDN加速缓存不刷新问题</title>
      <link>https://kayleh.top/%E5%85%B3%E4%BA%8Ecdn%E5%8A%A0%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%8D%E5%88%B7%E6%96%B0%E7%9A%84%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Thu, 20 Aug 2020 14:20:58 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%85%B3%E4%BA%8Ecdn%E5%8A%A0%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%8D%E5%88%B7%E6%96%B0%E7%9A%84%E8%A7%A3%E5%86%B3/</guid>
      <description>&lt;hr&gt;</description>
    </item>
    
    <item>
      <title>SpringCloud Alibaba</title>
      <link>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%849/</link>
      <pubDate>Wed, 19 Aug 2020 20:25:56 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%849/</guid>
      <description>&lt;p&gt;SpringCloud Alibaba&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SpringCloud Sleuth分布式请求链路追踪</title>
      <link>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%848/</link>
      <pubDate>Wed, 19 Aug 2020 17:52:50 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%848/</guid>
      <description>&lt;p&gt;SpringCloud Sleuth分布式请求链路追踪&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SpringCloud Stream消息驱动</title>
      <link>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%847/</link>
      <pubDate>Fri, 14 Aug 2020 23:33:07 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%847/</guid>
      <description>&lt;p&gt;SpringCloud Stream消息驱动&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SpringCloud Bus消息总线</title>
      <link>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%846/</link>
      <pubDate>Fri, 14 Aug 2020 23:29:28 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%846/</guid>
      <description>&lt;p&gt;SpringCloud Bus 消息总线&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SpringCloud config分布式配置中心</title>
      <link>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%845/</link>
      <pubDate>Fri, 14 Aug 2020 23:26:05 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%845/</guid>
      <description>&lt;p&gt;SpringCloud config分布式配置中心&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>GateWay服务限流</title>
      <link>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%844/</link>
      <pubDate>Fri, 14 Aug 2020 23:21:47 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%844/</guid>
      <description>&lt;p&gt;GateWay服务限流&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ribbon负载均衡服务调用、服务降级</title>
      <link>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%843/</link>
      <pubDate>Fri, 14 Aug 2020 23:14:13 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%843/</guid>
      <description>&lt;p&gt;Ribbon负载均衡服务调用、服务降级&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Eureka服务注册与发现</title>
      <link>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%842/</link>
      <pubDate>Fri, 14 Aug 2020 23:03:57 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%842/</guid>
      <description>&lt;p&gt;Eureka服务注册与发现&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SpringCloud</title>
      <link>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%841/</link>
      <pubDate>Mon, 03 Aug 2020 14:07:44 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%841/</guid>
      <description>&lt;p&gt;SpringCloud——基于分布式的微服务架构&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MYSQL</title>
      <link>https://kayleh.top/mysql/</link>
      <pubDate>Sun, 02 Aug 2020 22:54:25 +0800</pubDate>
      
      <guid>https://kayleh.top/mysql/</guid>
      <description>&lt;h1 id=&#34;mysql索引&#34;&gt;MYSQL索引&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>HTTP</title>
      <link>https://kayleh.top/http/</link>
      <pubDate>Mon, 27 Jul 2020 10:58:34 +0800</pubDate>
      
      <guid>https://kayleh.top/http/</guid>
      <description></description>
    </item>
    
    <item>
      <title>TCP/IP</title>
      <link>https://kayleh.top/tcp-ip/</link>
      <pubDate>Mon, 27 Jul 2020 10:58:27 +0800</pubDate>
      
      <guid>https://kayleh.top/tcp-ip/</guid>
      <description>&lt;h1 id=&#34;tcpip协议&#34;&gt;TCP/IP协议&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>计算机网络概论</title>
      <link>https://kayleh.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1/</link>
      <pubDate>Sat, 25 Jul 2020 13:28:42 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1/</guid>
      <description>&lt;h1 id=&#34;计算机网络&#34;&gt;计算机网络&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://kayleh.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 24 Jul 2020 17:48:28 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h1 id=&#34;设计模式&#34;&gt;设计模式&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>数据结构与算法</title>
      <link>https://kayleh.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 24 Jul 2020 17:19:17 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;数据结构与算法&#34;&gt;数据结构与算法&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>introduction to operating system</title>
      <link>https://kayleh.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</link>
      <pubDate>Fri, 24 Jul 2020 14:46:46 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</guid>
      <description>&lt;h1 id=&#34;操作系统概论&#34;&gt;操作系统概论&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://kayleh.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Fri, 24 Jul 2020 14:30:23 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
      <description>&lt;h1 id=&#34;计算机网络&#34;&gt;计算机网络&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>XML</title>
      <link>https://kayleh.top/xml/</link>
      <pubDate>Fri, 24 Jul 2020 14:24:49 +0800</pubDate>
      
      <guid>https://kayleh.top/xml/</guid>
      <description>&lt;h1 id=&#34;xml&#34;&gt;XML&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>JDBC</title>
      <link>https://kayleh.top/jdbc/</link>
      <pubDate>Thu, 16 Jul 2020 15:06:43 +0800</pubDate>
      
      <guid>https://kayleh.top/jdbc/</guid>
      <description>&lt;h1 id=&#34;jdbc&#34;&gt;JDBC&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>contract</title>
      <link>https://kayleh.top/contract/</link>
      <pubDate>Wed, 15 Jul 2020 21:57:44 +0800</pubDate>
      
      <guid>https://kayleh.top/contract/</guid>
      <description></description>
    </item>
    
    <item>
      <title>J2EE</title>
      <link>https://kayleh.top/j2ee/</link>
      <pubDate>Tue, 14 Jul 2020 13:44:34 +0800</pubDate>
      
      <guid>https://kayleh.top/j2ee/</guid>
      <description>&lt;h1 id=&#34;java-web&#34;&gt;Java Web&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>MVC</title>
      <link>https://kayleh.top/mvc/</link>
      <pubDate>Tue, 14 Jul 2020 13:43:03 +0800</pubDate>
      
      <guid>https://kayleh.top/mvc/</guid>
      <description>&lt;h1 id=&#34;mvc&#34;&gt;MVC&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>Mybatis</title>
      <link>https://kayleh.top/mybatis/</link>
      <pubDate>Tue, 14 Jul 2020 13:41:49 +0800</pubDate>
      
      <guid>https://kayleh.top/mybatis/</guid>
      <description>&lt;h1 id=&#34;mybatis&#34;&gt;MYBATIS&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>Spring</title>
      <link>https://kayleh.top/spring/</link>
      <pubDate>Tue, 14 Jul 2020 13:40:15 +0800</pubDate>
      
      <guid>https://kayleh.top/spring/</guid>
      <description>&lt;h1 id=&#34;spring&#34;&gt;SPRING&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>IO</title>
      <link>https://kayleh.top/io/</link>
      <pubDate>Tue, 14 Jul 2020 13:39:13 +0800</pubDate>
      
      <guid>https://kayleh.top/io/</guid>
      <description>&lt;h1 id=&#34;io&#34;&gt;IO&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>GC</title>
      <link>https://kayleh.top/gc/</link>
      <pubDate>Tue, 14 Jul 2020 13:38:14 +0800</pubDate>
      
      <guid>https://kayleh.top/gc/</guid>
      <description>&lt;h1 id=&#34;gc&#34;&gt;GC&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>JVM</title>
      <link>https://kayleh.top/jvm/</link>
      <pubDate>Tue, 14 Jul 2020 13:35:08 +0800</pubDate>
      
      <guid>https://kayleh.top/jvm/</guid>
      <description>&lt;h1 id=&#34;jvm&#34;&gt;JVM&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>Reflection</title>
      <link>https://kayleh.top/reflection/</link>
      <pubDate>Tue, 14 Jul 2020 13:33:21 +0800</pubDate>
      
      <guid>https://kayleh.top/reflection/</guid>
      <description>&lt;h1 id=&#34;reflection&#34;&gt;Reflection&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>JDK</title>
      <link>https://kayleh.top/jdk/</link>
      <pubDate>Tue, 14 Jul 2020 13:32:29 +0800</pubDate>
      
      <guid>https://kayleh.top/jdk/</guid>
      <description>&lt;h1 id=&#34;jdk&#34;&gt;JDK&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>Lock</title>
      <link>https://kayleh.top/lock/</link>
      <pubDate>Tue, 14 Jul 2020 13:31:29 +0800</pubDate>
      
      <guid>https://kayleh.top/lock/</guid>
      <description>&lt;h1 id=&#34;lock&#34;&gt;LOCK&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>Thread</title>
      <link>https://kayleh.top/thread/</link>
      <pubDate>Tue, 14 Jul 2020 13:30:23 +0800</pubDate>
      
      <guid>https://kayleh.top/thread/</guid>
      <description>&lt;h1 id=&#34;thread&#34;&gt;THREAD&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>Array</title>
      <link>https://kayleh.top/array/</link>
      <pubDate>Tue, 14 Jul 2020 13:29:08 +0800</pubDate>
      
      <guid>https://kayleh.top/array/</guid>
      <description>&lt;h1 id=&#34;array&#34;&gt;Array&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>J2SE</title>
      <link>https://kayleh.top/j2se/</link>
      <pubDate>Tue, 14 Jul 2020 13:27:19 +0800</pubDate>
      
      <guid>https://kayleh.top/j2se/</guid>
      <description>&lt;h1 id=&#34;object-oriented&#34;&gt;Object-oriented&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>https://kayleh.top/linux/</link>
      <pubDate>Thu, 02 Jul 2020 21:26:15 +0800</pubDate>
      
      <guid>https://kayleh.top/linux/</guid>
      <description>&lt;h2 id=&#34;虚拟机&#34;&gt;虚拟机&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>C pointer</title>
      <link>https://kayleh.top/c-prime-plus/</link>
      <pubDate>Sun, 28 Jun 2020 17:33:01 +0800</pubDate>
      
      <guid>https://kayleh.top/c-prime-plus/</guid>
      <description>&lt;h2 id=&#34;指针&#34;&gt;指针&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>https://kayleh.top/redis/</link>
      <pubDate>Sat, 27 Jun 2020 17:30:29 +0800</pubDate>
      
      <guid>https://kayleh.top/redis/</guid>
      <description>&lt;h1 id=&#34;redis&#34;&gt;Redis&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>Operating Systems</title>
      <link>https://kayleh.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 20 Jun 2020 21:14:21 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;h1 id=&#34;操作系统&#34;&gt;操作系统&lt;/h1&gt;
&lt;h3 id=&#34;os-kernel的特征&#34;&gt;OS Kernel的特征&lt;/h3&gt;</description>
    </item>
    
    <item>
      <title>encoding-algorithm</title>
      <link>https://kayleh.top/%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 19 Jun 2020 08:53:22 +0800</pubDate>
      
      <guid>https://kayleh.top/%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h2 id=&#34;编码算法&#34;&gt;编码算法&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>hash algorithm</title>
      <link>https://kayleh.top/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 17 Jun 2020 18:03:58 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h3 id=&#34;哈希算法&#34;&gt;哈希算法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>interpolation-search-algorithm</title>
      <link>https://kayleh.top/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 17 Jun 2020 09:18:21 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h3 id=&#34;插值查找算法&#34;&gt;插值查找算法&lt;/h3&gt;</description>
    </item>
    
    <item>
      <title>binary-search-algorithm</title>
      <link>https://kayleh.top/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 17 Jun 2020 09:04:50 +0800</pubDate>
      
      <guid>https://kayleh.top/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h3 id=&#34;二分查找算法&#34;&gt;二分查找算法&lt;/h3&gt;</description>
    </item>
    
    <item>
      <title>linear-search-algorithm</title>
      <link>https://kayleh.top/%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 17 Jun 2020 08:54:06 +0800</pubDate>
      
      <guid>https://kayleh.top/%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h3 id=&#34;线性查找算法&#34;&gt;线性查找算法&lt;/h3&gt;</description>
    </item>
    
    <item>
      <title>多线程</title>
      <link>https://kayleh.top/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 15 Jun 2020 09:13:04 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;多线程&#34;&gt;多线程&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>模板方法</title>
      <link>https://kayleh.top/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 13 Jun 2020 17:22:53 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;h4 id=&#34;模板方法&#34;&gt;模板方法&lt;/h4&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>访问者模式</title>
      <link>https://kayleh.top/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 13 Jun 2020 17:22:33 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h4 id=&#34;访问者&#34;&gt;访问者&lt;/h4&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://kayleh.top/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 13 Jun 2020 17:17:47 +0800</pubDate>
      
      <guid>https://kayleh.top/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h4 id=&#34;策略&#34;&gt;策略&lt;/h4&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>状态模式</title>
      <link>https://kayleh.top/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 13 Jun 2020 16:14:10 +0800</pubDate>
      
      <guid>https://kayleh.top/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h4 id=&#34;状态&#34;&gt;状态&lt;/h4&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://kayleh.top/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 13 Jun 2020 16:07:09 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h4 id=&#34;观察者&#34;&gt;观察者&lt;/h4&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>memo-mode</title>
      <link>https://kayleh.top/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 13 Jun 2020 15:20:47 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h4 id=&#34;备忘录模式&#34;&gt;备忘录模式&lt;/h4&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>中介者模式</title>
      <link>https://kayleh.top/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 13 Jun 2020 14:46:55 +0800</pubDate>
      
      <guid>https://kayleh.top/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h1 id=&#34;中介者模式&#34;&gt;中介者模式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>迭代器模式</title>
      <link>https://kayleh.top/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 13 Jun 2020 13:26:48 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;迭代器&#34;&gt;迭代器&lt;/h3&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>解释器模式</title>
      <link>https://kayleh.top/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 12 Jun 2020 21:31:18 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h1 id=&#34;解释器模式&#34;&gt;解释器模式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>https://kayleh.top/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 12 Jun 2020 18:12:06 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;命令模式&#34;&gt;命令模式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;**命令模式（Command Pattern）**是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>责任链模式</title>
      <link>https://kayleh.top/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 11 Jun 2020 19:48:35 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;责任链模式&#34;&gt;责任链模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;**责任链模式（Chain of Responsibility Pattern）**为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https://kayleh.top/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Jun 2020 20:46:15 +0800</pubDate>
      
      <guid>https://kayleh.top/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;代理模式&#34;&gt;代理模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;为其他对象提供一种代理以控制对这个对象的访问。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>享元模式</title>
      <link>https://kayleh.top/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Jun 2020 18:05:02 +0800</pubDate>
      
      <guid>https://kayleh.top/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;享元&#34;&gt;享元&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;运用共享技术有效地支持大量细粒度的对象。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>https://kayleh.top/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Jun 2020 15:37:54 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;外观模式&#34;&gt;外观模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>装饰器模式</title>
      <link>https://kayleh.top/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Jun 2020 15:10:41 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;装饰器模式&#34;&gt;装饰器模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>组合模式</title>
      <link>https://kayleh.top/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Jun 2020 14:39:48 +0800</pubDate>
      
      <guid>https://kayleh.top/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;组合模式&#34;&gt;组合模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>桥接模式</title>
      <link>https://kayleh.top/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Jun 2020 14:04:02 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;桥接模式&#34;&gt;桥接模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;将抽象部分与它的实现部分分离，使它们都可以独立地变化。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>https://kayleh.top/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 08 Jun 2020 14:28:13 +0800</pubDate>
      
      <guid>https://kayleh.top/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;适配器模式&#34;&gt;适配器模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>原型</title>
      <link>https://kayleh.top/%E5%8E%9F%E5%9E%8B/</link>
      <pubDate>Mon, 08 Jun 2020 09:43:14 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%8E%9F%E5%9E%8B/</guid>
      <description>&lt;h3 id=&#34;原型&#34;&gt;原型&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>生成器</title>
      <link>https://kayleh.top/%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Mon, 08 Jun 2020 09:39:43 +0800</pubDate>
      
      <guid>https://kayleh.top/%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>&lt;h3 id=&#34;生成器&#34;&gt;生成器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>工厂设计模式</title>
      <link>https://kayleh.top/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 06 Jun 2020 20:42:10 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;工厂设计模式&#34;&gt;工厂设计模式&lt;/h2&gt;
&lt;h3 id=&#34;工厂方法&#34;&gt;工厂方法&lt;/h3&gt;
&lt;p&gt;工厂方法即Factory Method，是一种对象创建型模式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://kayleh.top/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 06 Jun 2020 14:05:04 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;单例设计模式&#34;&gt;单例设计模式&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>合成复用原则</title>
      <link>https://kayleh.top/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</link>
      <pubDate>Fri, 05 Jun 2020 15:42:54 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</guid>
      <description>&lt;h3 id=&#34;合成复用原则&#34;&gt;合成复用原则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Composite Resue Principle&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>迪米特法则</title>
      <link>https://kayleh.top/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</link>
      <pubDate>Fri, 05 Jun 2020 11:09:31 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</guid>
      <description>&lt;h3 id=&#34;基本介绍&#34;&gt;基本介绍&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Demeter Principle&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>开闭原则</title>
      <link>https://kayleh.top/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link>
      <pubDate>Fri, 05 Jun 2020 09:07:12 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid>
      <description>&lt;h3 id=&#34;开闭原则&#34;&gt;开闭原则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Open Closed Principle&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本介绍&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>里氏替换原则</title>
      <link>https://kayleh.top/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 04 Jun 2020 18:13:11 +0800</pubDate>
      
      <guid>https://kayleh.top/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</guid>
      <description>&lt;h3 id=&#34;里氏替换原则&#34;&gt;里氏替换原则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Liskov Substitution Principle&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;里氏替换原则在1988年，由麻省理工学院的一位姓里的女士提出的。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>依赖倒转原则</title>
      <link>https://kayleh.top/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</link>
      <pubDate>Wed, 03 Jun 2020 20:29:20 +0800</pubDate>
      
      <guid>https://kayleh.top/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</guid>
      <description>&lt;h3 id=&#34;依赖倒转原则&#34;&gt;依赖倒转原则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Dependence Inversion Priciple&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>接口隔离原则</title>
      <link>https://kayleh.top/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</link>
      <pubDate>Wed, 03 Jun 2020 17:56:04 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</guid>
      <description>&lt;h3 id=&#34;接口隔离原则&#34;&gt;接口隔离原则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Interface Segregation Principle&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>单一职责原则</title>
      <link>https://kayleh.top/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</link>
      <pubDate>Wed, 03 Jun 2020 16:57:48 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</guid>
      <description>&lt;h3 id=&#34;单一职责原则&#34;&gt;单一职责原则&lt;/h3&gt;
&lt;hr&gt;</description>
    </item>
    
    <item>
      <title>XSS跨站脚本攻击</title>
      <link>https://kayleh.top/xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/</link>
      <pubDate>Sun, 31 May 2020 20:58:53 +0800</pubDate>
      
      <guid>https://kayleh.top/xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/</guid>
      <description>&lt;h3 id=&#34;xss跨站脚本攻击&#34;&gt;XSS跨站脚本攻击&lt;/h3&gt;</description>
    </item>
    
    <item>
      <title>SQL注入式攻击</title>
      <link>https://kayleh.top/sql%E6%B3%A8%E5%85%A5%E5%BC%8F%E6%94%BB%E5%87%BB/</link>
      <pubDate>Sat, 30 May 2020 21:13:52 +0800</pubDate>
      
      <guid>https://kayleh.top/sql%E6%B3%A8%E5%85%A5%E5%BC%8F%E6%94%BB%E5%87%BB/</guid>
      <description>&lt;h3 id=&#34;sql注入式攻击&#34;&gt;SQL注入式攻击&lt;/h3&gt;</description>
    </item>
    
    <item>
      <title>binary sort tree</title>
      <link>https://kayleh.top/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</link>
      <pubDate>Wed, 20 May 2020 20:42:23 +0800</pubDate>
      
      <guid>https://kayleh.top/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</guid>
      <description>&lt;h3 id=&#34;二叉排序树&#34;&gt;二叉排序树&lt;/h3&gt;
&lt;p&gt;二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。&lt;/p&gt;
&lt;p&gt;如果有相同的值，可以将该节点放在左子节点或右子节点&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>heap-sort</title>
      <link>https://kayleh.top/%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 18 May 2020 20:40:11 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>&lt;h3 id=&#34;堆排序&#34;&gt;堆排序&lt;/h3&gt;</description>
    </item>
    
    <item>
      <title>7 sorting algorithms</title>
      <link>https://kayleh.top/7%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 17 May 2020 21:42:21 +0800</pubDate>
      
      <guid>https://kayleh.top/7%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;7种排序算法&#34;&gt;7种排序算法&lt;/h1&gt;
&lt;h2 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>计算机组成原理</title>
      <link>https://kayleh.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 14 May 2020 22:04:21 +0800</pubDate>
      
      <guid>https://kayleh.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;h1 id=&#34;计算机组成原理&#34;&gt;计算机组成原理&lt;/h1&gt;
&lt;h4 id=&#34;1第一台电子计算机何时何地诞生英文全称&#34;&gt;1.第一台电子计算机何时何地诞生？英文全称？&lt;/h4&gt;
&lt;p&gt;1946年2月14日 美国宾夕法尼亚大学&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>queue</title>
      <link>https://kayleh.top/%E9%98%9F%E5%88%97/</link>
      <pubDate>Thu, 14 May 2020 16:52:39 +0800</pubDate>
      
      <guid>https://kayleh.top/%E9%98%9F%E5%88%97/</guid>
      <description>&lt;h3 id=&#34;队列&#34;&gt;队列&lt;/h3&gt;</description>
    </item>
    
    <item>
      <title>Inversion of Control控制反转</title>
      <link>https://kayleh.top/inversion-of-control%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Wed, 13 May 2020 16:42:55 +0800</pubDate>
      
      <guid>https://kayleh.top/inversion-of-control%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</guid>
      <description>&lt;h3 id=&#34;控制反转的定义&#34;&gt;控制反转的定义&lt;/h3&gt;</description>
    </item>
    
    <item>
      <title>LinkedList</title>
      <link>https://kayleh.top/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 12 May 2020 19:21:40 +0800</pubDate>
      
      <guid>https://kayleh.top/%E9%93%BE%E8%A1%A8/</guid>
      <description>&lt;p&gt;链表是有序的列表，但它在内存里是无序的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;%E9%93%BE%E8%A1%A8.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Stack</title>
      <link>https://kayleh.top/%E6%A0%88stack/</link>
      <pubDate>Mon, 11 May 2020 15:30:11 +0800</pubDate>
      
      <guid>https://kayleh.top/%E6%A0%88stack/</guid>
      <description>&lt;h2 id=&#34;栈stack&#34;&gt;栈(stack)&lt;/h2&gt;
&lt;p&gt;1&lt;code&gt;栈&lt;/code&gt;是一个&lt;strong&gt;先入后出&lt;/strong&gt;(FILO-First In Last Out)的有序列表。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SparseArray</title>
      <link>https://kayleh.top/sparsearray%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 07 May 2020 21:28:41 +0800</pubDate>
      
      <guid>https://kayleh.top/sparsearray%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</guid>
      <description>稀疏数组 ​	（稀疏数组）
定义 当一个数组中大部分的值未被使用，只有少部分的值的空间使用，造成了内存的浪费，这个时候就可以用到稀疏数组，保存需要的数据，节约内存空间。 当记录一个棋盘时：
记录棋盘的位置，只有两个内容，其他未被使用没有意义的值浪费了内存空间
使用稀疏数组代替二维数组，第0行表示稀疏数组的总行，总列和所需内容的个数。
实现 package com.kayleh.tmall.controller; /** * @Author: Wizard * @Date: 2020/5/7 9:16 */ public class SparseArray { public static void main(String[] args) { //创建一个二维数组  //0:表示没有棋子 1表示黑子 2表示蓝子  int chessArr[][] = new int[11][10]; chessArr[1][2] = 1; chessArr[2][3] = 2; for(int[] row:chessArr){ for(int data:row){ System.out.printf(&amp;#34;%d\t&amp;#34;,data); } System.out.println(); } int[][] array = getSparseArray(chessArr); System.out.println(&amp;#34;-------&amp;#34;); for(int i = 0 ; i&amp;lt; array.length;i++){ System.out.printf(&amp;#34;%d\t%d\t%d\t\n&amp;#34;,array[i][0],array[i][1],array[i][2]); } System.out.println(&amp;#34;--------&amp;#34;); int[][] startArr = recovery(array); for(int[] row:startArr){ for(int data:row){ System.</description>
    </item>
    
    <item>
      <title>面向对象</title>
      <link>https://kayleh.top/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81/</link>
      <pubDate>Wed, 29 Apr 2020 21:33:19 +0800</pubDate>
      
      <guid>https://kayleh.top/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81/</guid>
      <description>&lt;h2 id=&#34;面向对象的特征有哪些方面&#34;&gt;面向对象的特征有哪些方面&lt;/h2&gt;
&lt;h3 id=&#34;封装&#34;&gt;封装&lt;/h3&gt;
&lt;p&gt;最常见的是把属性私有化封装在一个类里面，只能通过方法去访问&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>dynamic-array</title>
      <link>https://kayleh.top/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 26 Apr 2020 09:02:37 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/</guid>
      <description>&lt;p&gt;动态数组&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spring、SpringMVC、Mybatis整合</title>
      <link>https://kayleh.top/springspringmvcmybatis%E6%95%B4%E5%90%88/</link>
      <pubDate>Mon, 20 Apr 2020 21:05:31 +0800</pubDate>
      
      <guid>https://kayleh.top/springspringmvcmybatis%E6%95%B4%E5%90%88/</guid>
      <description>SSM整合
整合说明 服务器开发分为三层,表现层、业务层、持久层 表现层使用SpringMVC实现,业务程使用Spring实现,持久层使用Mybatis实现 使用Spring框架来整合 SpringMVC和Mybatis框架 这里使用xml配置文件+注解的方式进行搭建
最终目标 最终实现通过前端页面对数据库进行查询和插入,实现用户的登录注册功能 准备 创建Maven工程 选择webapp 数据库准备 create database ssm; use ssm; create table account( id int primary key auto_increment, name varchar(20), money double ); ####创建目录 ####导入依赖 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.kayleh&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;SSM&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;SSM Maven Webapp&amp;lt;/name&amp;gt; &amp;lt;!-- FIXME change it to the project&amp;#39;s website --&amp;gt; &amp;lt;url&amp;gt;http://www.example.com&amp;lt;/url&amp;gt; &amp;lt;!--版本锁定--&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.7&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.7&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;spring.version&amp;gt;5.0.2.RELEASE&amp;lt;/spring.version&amp;gt; &amp;lt;slf4j.version&amp;gt;1.6.6&amp;lt;/slf4j.version&amp;gt; &amp;lt;log4j.version&amp;gt;1.2.12&amp;lt;/log4j.version&amp;gt; &amp;lt;mysql.version&amp;gt;5.1.6&amp;lt;/mysql.version&amp;gt; &amp;lt;mybatis.version&amp;gt;3.4.5&amp;lt;/mybatis.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.</description>
    </item>
    
    <item>
      <title>palindrome</title>
      <link>https://kayleh.top/%E5%9B%9E%E6%96%87%E6%95%B0/</link>
      <pubDate>Sun, 19 Apr 2020 21:17:57 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
      <description>什么是回文数？ 回文数指的是正序和倒序读都是一样的数，例如121从左到右，从右到左读都是121。任何一个自然数与它的倒序数相加，所得的和再与和的倒序数相加，……如此反复进行下去，经过有限次步骤后，最后必定能得到一个回文数。
问题：判断一个数是否为回文数，是返回true，否侧抛出false。 @题目来源lettcode 利用Java的StringBuilder通过把整数转换为字符串来实现↓ import java.util.Scanner; /** * @Author: Wizard * @Date: 2020/4/12 13:14 */ public class palindrome { public static boolean ispalindrome(int i) { String str = (new StringBuilder(i + &amp;#34;&amp;#34;)).reverse().toString(); return (i + &amp;#34;&amp;#34;).equals(str); } public static void main(String[] args) { while (true) { System.out.println(&amp;#34;输入需要判断的整数&amp;#34;); Scanner scanner = new Scanner(System.in); int str1 = scanner.nextInt(); System.out.println(ispalindrome(str1)); } } } /** * 输入需要判断的整数：1 * false * 输入需要判断的整数：12121 * true */  进阶：不改变整数为字符串 通过取整和取余获取整数中的数字进行比较 /** * @Author: Wizard * @Date: 2020/4/12 13:14 */ public class palindrome { public static boolean ispalindrome(int i) { if(i&amp;lt;0||(i%10==0&amp;amp;&amp;amp;i!</description>
    </item>
    
    <item>
      <title>SpringMVC@ModelAttribute的使用</title>
      <link>https://kayleh.top/springmvc-modelattribute/</link>
      <pubDate>Sun, 19 Apr 2020 21:04:07 +0800</pubDate>
      
      <guid>https://kayleh.top/springmvc-modelattribute/</guid>
      <description>@ModelAttribute？ @ModelAttribute的原理比较复杂，需要对源码有一定的理解。它可以使被
@ModelAttribute修饰的方法在控制器的处理方法之前调用。 但如果@ModelAttribute标注在方法的入参前，它可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数绑定到对象中，再传入入参。
 实际场景： Spring在进行数据库update全字段更新操作提交表单的时候，从页面获取的数据会封装成一个new的pojo对象，没有带的值为null；所以我们只能更新我们提交的数据。ModelAttribute暂时保存表单pojo对象，覆盖数据库保存的pojo对象的数据即可。
ModelAttribute提前与目标方法运行 /** * @author Kayleh */ @Controller public class ModelAttributeTest { @RequestMapping(&amp;#34;/update&amp;#34;) public String update(){ System.out.println(&amp;#34;页面update的bean对象：&amp;#34;+bean); } @ModelAttribute public void modelAttribute(){ System.out.println(&amp;#34;ModelAttribute调用了...&amp;#34;); } ===========输出========= ModelAttribute调用了... 页面update的bean对象：bean{......} 可以得出：ModelAttribute标注的方法总会在目标方法(update)前执行。 ModelAttribute可以取出隐含对象的值 @ModelAttribute public void TestModelAttribute(Map&amp;lt;String, Object&amp;gt; map){ POJO pojo = new POJO(&amp;#34;kayleh&amp;#34;, 1104); map.put(&amp;#34;value&amp;#34;,pojo); System.out.println(&amp;#34;modelAttribute方法...); } @RequestMapping(&amp;#34;/updateBook&amp;#34;) public String updateBook(@RequestParam(value=&amp;#34;author&amp;#34;)String author, Map&amp;lt;String, Object&amp;gt; model, HttpServletRequest request, @ModelAttribute(&amp;#34;value&amp;#34;)POJO pojo ){ System.out.println(pojo); return &amp;#34;ok&amp;#34;; } @ModelAttribute(&amp;ldquo;value&amp;rdquo;)这里如果指定的&amp;quot;value&amp;quot;,value就是从map取出参数的key.如果是@ModelAttribute,没有指定key,SpringMVC会默认使用返回值类型的首字母小写作为key.如pOJO.</description>
    </item>
    
    <item>
      <title>Spring架构</title>
      <link>https://kayleh.top/spring%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Sun, 19 Apr 2020 20:40:54 +0800</pubDate>
      
      <guid>https://kayleh.top/spring%E6%9E%B6%E6%9E%84/</guid>
      <description>架构图</description>
    </item>
    
    <item>
      <title>unix的常用指令</title>
      <link>https://kayleh.top/unix/</link>
      <pubDate>Sat, 14 Dec 2019 13:30:23 +0800</pubDate>
      
      <guid>https://kayleh.top/unix/</guid>
      <description>unix的常用指令 ls 显示指定目录下的文件目录清单相当于dos下的dir命令。 pwd 显示当前目录。 mkdir 在当前目录下创建目录。 rm 删除文件或目录。 cp 复制文件。 mv 移动文件。 cd 切换工作目录。 ps 查看进程。 ftp 传送文件。 telnet 远程登录命令。 ping 用来测试本机与目标主机是否联通。 env 查看当前系统中的环境变量。 more 分屏显示指定文件的内容。 echo在终端上显示你要显示的内容，向C语言中的printf函数。 微信公众号:每日学习干货</description>
    </item>
    
    <item>
      <title>SpringMVC环境搭建</title>
      <link>https://kayleh.top/springmvc%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Sun, 14 Jul 2019 13:30:23 +0800</pubDate>
      
      <guid>https://kayleh.top/springmvc%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>&lt;h2 id=&#34;springmvc&#34;&gt;SpringMVC&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>concurrency-principle</title>
      <link>https://kayleh.top/%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 01 Jan 2019 13:30:23 +0800</pubDate>
      
      <guid>https://kayleh.top/%E5%B9%B6%E5%8F%91%E5%8E%9F%E7%90%86/</guid>
      <description>多线程 为什么要创建线程池 如果系统要运行多个线程,大量反复的启动创建和回收线程会非常占用系统资源,导致性能下降. 创建线程池,可以: 1.降低资源消耗 2.提升响应速度 3.提高
线程池原理  线程池一般由两种角色构成：多个工作线程 和 一个阻塞队列。
  工作线程 : 工作线程是一组已经处在运行中的线程，它们不断地向阻塞队列中领取任务执行。
  阻塞队列 : 阻塞队列用于存储工作线程来不及处理的任务。当工作线程都在执行任务时，到来的新任务就只能暂时在阻塞队列中存储。
   提交一个任务到线程池中,线程池的处理流程如下: 1.判断线程池里的核心线程是否都在执行任务,如果不是(核心线程空闲或者核心线程没有被创建)则创建一个新的工作线程来执行任务.如果核心线程都在执行任务,则进入下个流程. 2.线程池判断工作队列是否已满,如果工作路径没有满,则新提交的任务储存在这个工作队列里.如果工作队列满了,则进入下个流程. 3.判断线程池里的线程是否都处于工作状态,如果没有,则创建一个新的工作线程来执行任务.如果已经满了,则交给饱和策略来处理这个任务. 线程池的分类 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); ThreadPoolExecutor是线程池的真正实现, 他通过构造方法的一系列参数，来构成不同配置的线程池。 corePoolSize： 核心池的大小。 当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中 maximumPoolSize： 线程池最大线程数，它表示在线程池中最多能创建多少个线程； keepAliveTime： 表示线程没有任务执行时最多保持多久时间会终止。 unit： 参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性。 workQueue：一个阻塞队列，提交的任务将会被放到这个队列里。 threadFactory：线程工厂，用来创建线程，主要是为了给线程起名字，默认工厂的线程名字：pool-1-thread-3。 handler：拒绝策略，当线程池里线程被耗尽，且队列也满了的时候会调用。
线程池的创建方法 Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：
newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 案例演示:
newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</description>
    </item>
    
  </channel>
</rss>
