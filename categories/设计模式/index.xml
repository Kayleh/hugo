<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on Kayleh</title>
    <link>https://blog.kayleh.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on Kayleh</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 13 Jun 2020 17:22:53 +0800</lastBuildDate><atom:link href="https://blog.kayleh.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>模板方法</title>
      <link>https://blog.kayleh.top/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 13 Jun 2020 17:22:53 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</guid>
      <description>&lt;h4 id=&#34;模板方法&#34;&gt;模板方法&lt;/h4&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>状态模式</title>
      <link>https://blog.kayleh.top/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 13 Jun 2020 16:14:10 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h4 id=&#34;状态&#34;&gt;状态&lt;/h4&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>中介者模式</title>
      <link>https://blog.kayleh.top/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 13 Jun 2020 14:46:55 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h1 id=&#34;中介者模式&#34;&gt;中介者模式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>https://blog.kayleh.top/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 12 Jun 2020 18:12:06 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;命令模式&#34;&gt;命令模式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;**命令模式（Command Pattern）**是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>责任链模式</title>
      <link>https://blog.kayleh.top/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 11 Jun 2020 19:48:35 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;责任链模式&#34;&gt;责任链模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;**责任链模式（Chain of Responsibility Pattern）**为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>享元模式</title>
      <link>https://blog.kayleh.top/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Jun 2020 18:05:02 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;享元&#34;&gt;享元&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;运用共享技术有效地支持大量细粒度的对象。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>https://blog.kayleh.top/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Jun 2020 15:37:54 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;外观模式&#34;&gt;外观模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>装饰器模式</title>
      <link>https://blog.kayleh.top/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Jun 2020 15:10:41 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;装饰器模式&#34;&gt;装饰器模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>组合模式</title>
      <link>https://blog.kayleh.top/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Jun 2020 14:39:48 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;组合模式&#34;&gt;组合模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>桥接模式</title>
      <link>https://blog.kayleh.top/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Jun 2020 14:04:02 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;桥接模式&#34;&gt;桥接模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;将抽象部分与它的实现部分分离，使它们都可以独立地变化。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>https://blog.kayleh.top/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 08 Jun 2020 14:28:13 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h3 id=&#34;适配器模式&#34;&gt;适配器模式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>原型</title>
      <link>https://blog.kayleh.top/%E5%8E%9F%E5%9E%8B/</link>
      <pubDate>Mon, 08 Jun 2020 09:43:14 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E5%8E%9F%E5%9E%8B/</guid>
      <description>&lt;h3 id=&#34;原型&#34;&gt;原型&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>生成器</title>
      <link>https://blog.kayleh.top/%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Mon, 08 Jun 2020 09:39:43 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>&lt;h3 id=&#34;生成器&#34;&gt;生成器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>依赖倒转原则</title>
      <link>https://blog.kayleh.top/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</link>
      <pubDate>Wed, 03 Jun 2020 20:29:20 +0800</pubDate>
      
      <guid>https://blog.kayleh.top/%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99/</guid>
      <description>&lt;h3 id=&#34;依赖倒转原则&#34;&gt;依赖倒转原则&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Dependence Inversion Priciple&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>
