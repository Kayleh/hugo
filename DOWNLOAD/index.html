<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://kayleh.top/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://kayleh.top/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/github.min.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/github-style.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/light.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/dark.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/syntax.css' />
    <title>Download - Kayleh</title>
    
    <link rel="icon" type="image/x-icon" href='https://kayleh.top/images/favicon.ico'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="Java 多线程下载器的设计与实现 应用并发的场景有很多，下载文件就是一个很常见的并发场景。
为什么会想写多线程下载器呢？不知道你用过 IDM（Internet Download Manager）没，我刚使用 IDM 时，就被它的下载方式吸引了。
用 IDM 下载文件时，能够直观地看到它的下载过程：固定用 N 个线程下载文件，一开始先将文件分为 N 段，每段用一个线程下载，当某一段下载完成之后，对应的线程就空闲了，此时怎么做呢？从剩余的 N - 1 段中取出最大的一段，一分为二，这样就又有了 N 段的数据，让空闲的线程去下载新划分出来的这一段。
每当有一个线程完成下载任务时，就不断从剩余的部分中划分出一段给它下载，直到整个文件的所有部分都下载完毕。
当然，文件并不能被无限地分段，IDM 会设定一个段的阈值，当剩余的最大段小于这个阈值的时候，就不再分段了给空闲的线程了，只等待活动中的所有线程下载完毕。
说完 IDM 的下载策略，我们大致有了思路。不过优秀的软件不是一蹴而就的，虽然我们想写出像 IDM 的下载器，但还需要从简单的实现开始，不断迭代优化。
所以我们一开始采用的策略是：固定 N 个线程，并将文件划分为 N 段，每个线程负责下载一段数据。
实现步骤 判断服务器是否支持断点续传
首先要明确的是，多线程下载文件利用的是每个线程下载文件的一部分，那么就需要 HTTP 服务器支持请求部分数据，或者说断点续传，因此第一步需要判断目标文件是否支持断点续传。
HTTP 请求头中有一个 Range 字段，可以用来指定要请求的数据范围，例如我们要请求从第 10 字节到第 20 字节的数据，可以将该字段写为 Range:bytes=10-20。
相应的，如果 HTTP 服务器支持断点续传，那么对于指定了 Range 字段的请求，会返回 206 状态码。
我们用 Curl 来测试一下：
curl -I --header &amp;#34;Range: bytes=0-&amp;#34; http://mirrors.163.com/debian/ls-lR.gz 得到的响应：
HTTP/1.1 206 Partial Content Server: nginx Date: Wed, 25 Apr 2018 02:57:56 GMT Content-Type: application/octet-stream Content-Length: 15316619 Connection: keep-alive Last-Modified: Mon, 23 Apr 2018 14:38:44 GMT ETag: &amp;quot;5addeff4-e9b68b&amp;quot; Content-Range: bytes 0-15316618/15316619 我们设置 Range: bytes=0- ，表示请求从第 0 字节到最后一字节的数据，那为什么还要指定该字段呢？这是出于两方面的原因：一是判断响应的状态码是否为 206，二是得到文件的大小。" />
<meta name="keywords"
  content='' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://kayleh.top/download/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Download - Kayleh" />
<meta name="twitter:description"
  content="Java 多线程下载器的设计与实现 应用并发的场景有很多，下载文件就是一个很常见的并发场景。
为什么会想写多线程下载器呢？不知道你用过 IDM（Internet Download Manager）没，我刚使用 IDM 时，就被它的下载方式吸引了。
用 IDM 下载文件时，能够直观地看到它的下载过程：固定用 N 个线程下载文件，一开始先将文件分为 N 段，每段用一个线程下载，当某一段下载完成之后，对应的线程就空闲了，此时怎么做呢？从剩余的 N - 1 段中取出最大的一段，一分为二，这样就又有了 N 段的数据，让空闲的线程去下载新划分出来的这一段。
每当有一个线程完成下载任务时，就不断从剩余的部分中划分出一段给它下载，直到整个文件的所有部分都下载完毕。
当然，文件并不能被无限地分段，IDM 会设定一个段的阈值，当剩余的最大段小于这个阈值的时候，就不再分段了给空闲的线程了，只等待活动中的所有线程下载完毕。
说完 IDM 的下载策略，我们大致有了思路。不过优秀的软件不是一蹴而就的，虽然我们想写出像 IDM 的下载器，但还需要从简单的实现开始，不断迭代优化。
所以我们一开始采用的策略是：固定 N 个线程，并将文件划分为 N 段，每个线程负责下载一段数据。
实现步骤 判断服务器是否支持断点续传
首先要明确的是，多线程下载文件利用的是每个线程下载文件的一部分，那么就需要 HTTP 服务器支持请求部分数据，或者说断点续传，因此第一步需要判断目标文件是否支持断点续传。
HTTP 请求头中有一个 Range 字段，可以用来指定要请求的数据范围，例如我们要请求从第 10 字节到第 20 字节的数据，可以将该字段写为 Range:bytes=10-20。
相应的，如果 HTTP 服务器支持断点续传，那么对于指定了 Range 字段的请求，会返回 206 状态码。
我们用 Curl 来测试一下：
curl -I --header &amp;#34;Range: bytes=0-&amp;#34; http://mirrors.163.com/debian/ls-lR.gz 得到的响应：
HTTP/1.1 206 Partial Content Server: nginx Date: Wed, 25 Apr 2018 02:57:56 GMT Content-Type: application/octet-stream Content-Length: 15316619 Connection: keep-alive Last-Modified: Mon, 23 Apr 2018 14:38:44 GMT ETag: &amp;quot;5addeff4-e9b68b&amp;quot; Content-Range: bytes 0-15316618/15316619 我们设置 Range: bytes=0- ，表示请求从第 0 字节到最后一字节的数据，那为什么还要指定该字段呢？这是出于两方面的原因：一是判断响应的状态码是否为 206，二是得到文件的大小。" />
<meta name="twitter:site" content="https://kayleh.top" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image"
  content="https://kayleh.top">


<meta property="og:type" content="article" />
<meta property="og:title" content="Download - Kayleh">
<meta property="og:description"
  content="Java 多线程下载器的设计与实现 应用并发的场景有很多，下载文件就是一个很常见的并发场景。
为什么会想写多线程下载器呢？不知道你用过 IDM（Internet Download Manager）没，我刚使用 IDM 时，就被它的下载方式吸引了。
用 IDM 下载文件时，能够直观地看到它的下载过程：固定用 N 个线程下载文件，一开始先将文件分为 N 段，每段用一个线程下载，当某一段下载完成之后，对应的线程就空闲了，此时怎么做呢？从剩余的 N - 1 段中取出最大的一段，一分为二，这样就又有了 N 段的数据，让空闲的线程去下载新划分出来的这一段。
每当有一个线程完成下载任务时，就不断从剩余的部分中划分出一段给它下载，直到整个文件的所有部分都下载完毕。
当然，文件并不能被无限地分段，IDM 会设定一个段的阈值，当剩余的最大段小于这个阈值的时候，就不再分段了给空闲的线程了，只等待活动中的所有线程下载完毕。
说完 IDM 的下载策略，我们大致有了思路。不过优秀的软件不是一蹴而就的，虽然我们想写出像 IDM 的下载器，但还需要从简单的实现开始，不断迭代优化。
所以我们一开始采用的策略是：固定 N 个线程，并将文件划分为 N 段，每个线程负责下载一段数据。
实现步骤 判断服务器是否支持断点续传
首先要明确的是，多线程下载文件利用的是每个线程下载文件的一部分，那么就需要 HTTP 服务器支持请求部分数据，或者说断点续传，因此第一步需要判断目标文件是否支持断点续传。
HTTP 请求头中有一个 Range 字段，可以用来指定要请求的数据范围，例如我们要请求从第 10 字节到第 20 字节的数据，可以将该字段写为 Range:bytes=10-20。
相应的，如果 HTTP 服务器支持断点续传，那么对于指定了 Range 字段的请求，会返回 206 状态码。
我们用 Curl 来测试一下：
curl -I --header &amp;#34;Range: bytes=0-&amp;#34; http://mirrors.163.com/debian/ls-lR.gz 得到的响应：
HTTP/1.1 206 Partial Content Server: nginx Date: Wed, 25 Apr 2018 02:57:56 GMT Content-Type: application/octet-stream Content-Length: 15316619 Connection: keep-alive Last-Modified: Mon, 23 Apr 2018 14:38:44 GMT ETag: &amp;quot;5addeff4-e9b68b&amp;quot; Content-Range: bytes 0-15316618/15316619 我们设置 Range: bytes=0- ，表示请求从第 0 字节到最后一字节的数据，那为什么还要指定该字段呢？这是出于两方面的原因：一是判断响应的状态码是否为 206，二是得到文件的大小。" />
<meta property="og:url" content="https://kayleh.top/download/" />
<meta property="og:site_name" content="Download" />
<meta property="og:image"
  content="https://kayleh.top">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2021-03-16 01:18:07 &#43;0800 CST" />










</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://kayleh.top">
        <svg class="octicon" height="32" viewBox="0 0 16 16" version="1.1" width="32">
          <path fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd"
            d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          <form target="_blank" action="https://www.google.com/search" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
              <input type="hidden" name="q" value="site:https://kayleh.top">
            </label>
          </form>
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://kayleh.top">
        <svg class="octicon octicon-mark-github v-align-middle" height="32" viewBox="0 0 16 16" version="1.1"
          width="32">
          <path fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>
  
<div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://kayleh.top">
                  <img class=" avatar-user"
                    src="http://cdn.jsdelivr.net/gh/kayleh/cdn/img/2.jpg"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://kayleh.top">Kayleh</a></span><span
                    class="path-divider">/</span><strong class="css-truncate-target mr-1" style="max-width: 410px"><a
                      href="https://kayleh.top/download/">Download</a></strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Tue, 16 Mar 2021 01:18:07 &#43;0800"
                    class="no-wrap">
                    Tue, 16 Mar 2021 01:18:07 &#43;0800</relative-time>

                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div class="file-header d-flex flex-md-items-center flex-items-start">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    2846 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="/tags/c">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      C
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5">
                <article class="markdown-body entry-content container-lg"><h1 id="java-多线程下载器的设计与实现">Java 多线程下载器的设计与实现</h1>
<p>应用并发的场景有很多，下载文件就是一个很常见的并发场景。</p>
<p>为什么会想写多线程下载器呢？不知道你用过 IDM（Internet Download Manager）没，我刚使用 IDM 时，就被它的下载方式吸引了。</p>
<p>用 IDM 下载文件时，能够直观地看到它的下载过程：固定用 N 个线程下载文件，一开始先将文件分为 N 段，每段用一个线程下载，当某一段下载完成之后，对应的线程就空闲了，此时怎么做呢？从剩余的 N - 1 段中取出最大的一段，一分为二，这样就又有了 N 段的数据，让空闲的线程去下载新划分出来的这一段。</p>
<p>每当有一个线程完成下载任务时，就不断从剩余的部分中划分出一段给它下载，直到整个文件的所有部分都下载完毕。</p>
<p>当然，文件并不能被无限地分段，IDM 会设定一个段的阈值，当剩余的最大段小于这个阈值的时候，就不再分段了给空闲的线程了，只等待活动中的所有线程下载完毕。</p>
<p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/DOWNLOAD/idm.png" alt="img"></p>
<p>说完 IDM 的下载策略，我们大致有了思路。不过优秀的软件不是一蹴而就的，虽然我们想写出像 IDM 的下载器，但还需要从简单的实现开始，不断迭代优化。</p>
<p>所以我们一开始采用的策略是：固定 N 个线程，并将文件划分为 N 段，每个线程负责下载一段数据。</p>
<h3 id="实现步骤">实现步骤</h3>
<p><strong>判断服务器是否支持断点续传</strong></p>
<p>首先要明确的是，多线程下载文件利用的是每个线程下载文件的一部分，那么就需要 HTTP 服务器支持请求部分数据，或者说断点续传，因此第一步需要判断目标文件是否支持断点续传。</p>
<p>HTTP 请求头中有一个 <code>Range</code> 字段，可以用来指定要请求的数据范围，例如我们要请求从第 10 字节到第 20 字节的数据，可以将该字段写为 <code>Range:bytes=10-20</code>。</p>
<p>相应的，如果 HTTP 服务器支持断点续传，那么对于指定了 <code>Range</code> 字段的请求，会返回 206 状态码。</p>
<p>我们用 Curl 来测试一下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">curl -I --header <span style="color:#e6db74">&#34;Range: bytes=0-&#34;</span> http://mirrors.163.com/debian/ls-lR.gz
</code></pre></div><p>得到的响应：</p>
<pre><code class="language-null" data-lang="null">HTTP/1.1 206 Partial Content
Server: nginx
Date: Wed, 25 Apr 2018 02:57:56 GMT
Content-Type: application/octet-stream
Content-Length: 15316619
Connection: keep-alive
Last-Modified: Mon, 23 Apr 2018 14:38:44 GMT
ETag: &quot;5addeff4-e9b68b&quot;
Content-Range: bytes 0-15316618/15316619
</code></pre><p>我们设置 <code>Range: bytes=0-</code> ，表示请求从第 0 字节到最后一字节的数据，那为什么还要指定该字段呢？这是出于两方面的原因：一是判断响应的状态码是否为 206，二是得到文件的大小。</p>
<p>如果服务器支持断点续传，那么我们采用多线程进行下载，如果不支持断点续传，就采用单线程下载。</p>
<p><strong>文件分段</strong></p>
<p>我们得到了文件的大小 fileSize，将其分为 N 段，则每一段的大小为 <code>fileSize / N</code>，由于文件通常不会正好被分为 N 段，因此最后一段就等于剩余的部分的大小。</p>
<p>我们用一个数组 endPoint 来存放每一段的起止位置，例如一个 10 B 的文件，起止范围是 0~9，如果分为 3 段下载，那么 <code>endPoint = {0, 3, 6, 10}</code>，对每段来说是左闭右开区间。</p>
<p>解释：对于第 i 段（i 从 0 开始）来说，从 <code>endPoint[i]</code> 开始下载，在 <code>endPoint[i + 1] - 1</code> 处停止。同理，对第 i + 1 段来说，从 <code>endPoint[i + 1]</code> 开始，在 <code>endPoint[i + 2] - 1</code> 处停止。</p>
<p><strong>创建下载线程</strong></p>
<p>我们为每一段创建一个下载线程进行下载，每一段都存放在一个单独的临时文件中。</p>
<p>下载线程需要做的事情可以总结如下：</p>
<ul>
<li>设置请求头的 <code>Range</code> 字段来指定请求范围</li>
<li>设置超时时间</li>
<li>连接 HTTP 服务器</li>
<li>创建临时文件（第一次下载该段）</li>
<li>读取服务器返回的数据，写入到临时文件，直到读取的字节数等于该段的大小</li>
<li>关闭临时文件</li>
</ul>
<p>上面是顺利下载的流程，我们还需要在出现下列问题时进行重试：</p>
<ul>
<li>如果连接时间或读取时间超时</li>
<li>临时文件读写出错</li>
</ul>
<p>这样又有问题了，对于该线程来说，重试时是重新下载整段，还是接着下载剩余部分？我们知道，最好就是接着下载还没下完的那部分，那如何实现呢？</p>
<p>我们可以这么做：每个线程保存自己负责部分的起止位置，在刚启动线程时，起止位置就是段的起止位置，创建临时文件写出已下载的数据。在下载数据时，实时更新线程的起始位置为当前已下载字节的下一个字节，当出错需要重试时，直接从该位置开始，并且写出到之前创建的临时文件中。</p>
<p><strong>创建监视线程</strong></p>
<p>我们创建一个守护线程，负责监视文件的下载进度、下载速度、当前活跃线程数，在各线程下载结束后，通知主线程做下一步处理。</p>
<p><strong>处理临时文件</strong></p>
<p>当主线程收到通知，所有部分都下载完成时，就需要对临时文件进行清理。</p>
<p>如果是多线程下载的文件，那么需要对多个临时文件进行合并。</p>
<p>如果是单线程下载的文件，则对临时文件进行重命名。</p>
<h3 id="具体实现">具体实现</h3>
<p>这里给出程序的轮廓，进行整体上的介绍，完整的源码可查看 Github：https://github.com/wrayzheng/java-multithread-downloader</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HttpDownloader</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> resumable<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> URL url<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> File localFile<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> endPoint<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> Object waiting <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Object<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">private</span> AtomicInteger downloadedBytes <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">private</span> AtomicInteger aliveThreads <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> multithreaded <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> fileSize <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> THREAD_NUM <span style="color:#f92672">=</span> 5<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> TIME_OUT <span style="color:#f92672">=</span> 5000<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MIN_SIZE <span style="color:#f92672">=</span> 2 <span style="color:#f92672">&lt;&lt;</span> 20<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HttpDownloader</span><span style="color:#f92672">(</span>String Url<span style="color:#f92672">,</span> String localPath<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> MalformedURLException <span style="color:#f92672">{...}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">HttpDownloader</span><span style="color:#f92672">(</span>String Url<span style="color:#f92672">,</span> String localPath<span style="color:#f92672">,</span>
            <span style="color:#66d9ef">int</span> threadNum<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> timeout<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> MalformedURLException <span style="color:#f92672">{...}</span>

    <span style="color:#75715e">//开始下载文件
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{...}</span>

    <span style="color:#75715e">//检测目标文件是否支持断点续传，以决定是否开启多线程下载文件的不同部分
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">supportResumeDownload</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{...}</span>

    <span style="color:#75715e">//监测下载速度及下载状态，下载完成时通知主线程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">startDownloadMonitor</span><span style="color:#f92672">()</span> <span style="color:#f92672">{...}</span>

    <span style="color:#75715e">//对临时文件进行合并或重命名
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cleanTempFile</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{...}</span>

    <span style="color:#75715e">//合并多线程下载产生的多个临时文件
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span><span style="color:#f92672">()</span> <span style="color:#f92672">{...}</span>

    <span style="color:#75715e">//一个下载线程负责下载文件的某一部分，如果失败则自动重试，直到下载完成
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DownloadThread</span> <span style="color:#66d9ef">extends</span> Thread <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> id<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> start<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> end<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">private</span> OutputStream out<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DownloadThread</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> id<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> start<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> end<span style="color:#f92672">)</span> <span style="color:#f92672">{...}</span>

        <span style="color:#75715e">//保证文件的该部分数据下载完成
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">@Override</span>
        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{...}</span>

        <span style="color:#75715e">//下载文件指定范围的部分
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">download</span><span style="color:#f92672">()</span> <span style="color:#f92672">{...}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这里将 DownloadThread 定义为 HttpDownloader 的内部类，这是因为一个 HttpDownloader 实例对应一个文件下载任务，该实例中存放了该任务的各种数据，而下载线程是与该任务是关联的，需要用到这些数据，因此定义为内部类可以直接共享这些数据，从而避免过多的参数传递和存储。</p>
<p>要下载一个文件，首先创建一个 HttpDownloader 实例，必须传入的参数是目标文件 URL 和本地的存储位置，可选参数是线程数和超时时间。</p>
<p>HttpDownloader 的入口方法为 get()，它的工作如下：</p>
<ul>
<li>调用 supportResumeDownload() 方法判断目标文件是否支持断点续传以及是否大于设定的文件最小值，以决定是否采取多线程的下载方式；</li>
<li>计算每一段的起止位置，存入 endPoint；</li>
<li>创建 DownloadThread 线程进行下载；</li>
<li>调用 startDownloadMonitor() 方法启动监视线程；</li>
<li>等待文件下载完毕；</li>
<li>调用 cleanTempFile() 处理临时文件；</li>
<li>输出结束信息。</li>
</ul>
<p>再来介绍一下 DownloadThread，它的入口方法是 run()，工作如下：</p>
<ul>
<li>调用 download() 方法下载指定部分的数据;</li>
<li>如果成功，则线程结束，如果失败，则回到上一步。</li>
</ul>
<h3 id="下载测试">下载测试</h3>
<p>对于单个连接限速的服务器，多线程下载才能体现其优势，如果服务器本身不对连接限速，那么单个连接也能接近带宽上限。</p>
<p>我们来看看，对于单个连接速度远小于带宽时，单线程与多线程的对比。</p>
<p>首先是单个线程进行下载：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/DOWNLOAD/downloader-one-threads.gif" alt="img"></p>
<p>用时 54.133 秒，平均下载速度 42 KB/s。</p>
<p>开启 10 个线程进行下载：</p>
<p><img src="https://cdn.jsdelivr.net/gh/kayleh/cdn4/DOWNLOAD/downloader-ten-threads.gif" alt="img"></p>
<p>用时 10.144 秒，平均下载速度 228 KB/s。</p>
<p>可以看到，相比单线程下载，开启多线程之后下载速度有了巨大的提升。</p>
<p>在实际下载时，根据网络状况不同，设置不同的超时时间，对下载速度也有不小的影响。如果超时时间设置过小，会导致线程频繁建立连接，而建立连接是相对耗时的操作，导致下载效率低下；如果超时时间设置过长，可能连接已经失效，而客户端却长时间等待，无谓地消耗时间。</p>
<h3 id="结语">结语</h3>
<p>这是一个最基本的多线程下载器的实现，将文件划分为固定的 N 段，分配给 N 个线程下载，当一个线程下载完成后，该线程就随之结束了，没有被再次利用。</p>
<p>之后我会对该程序做进一步的优化，一方面会采取和 IDM 类似的下载策略，进一步提高下载效率，另一方面，也会在功能和鲁棒性方面进行加强，完善异常处理。</p>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://kayleh.top">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://kayleh.top/js/github-style.js"></script>



</html>