<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://kayleh.top/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://kayleh.top/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/github.min.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/github-style.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/light.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/dark.css' />
    <link rel="stylesheet" href='https://kayleh.top/css/syntax.css' />
    <title>Head First Map - Kayleh</title>
    
    <link rel="icon" type="image/x-icon" href='https://kayleh.top/images/favicon.ico'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="深入浅出Map  Map是java里边是一个接口,常见的实现类有HashMap、LinkedHashMap、TreeMap和ConcurrentHashMap
 HashMap底层数据结构是数组&#43;链表/红黑树
LinkedHashMap底层数据结构是数组&#43;链表&#43;双向链表
TreeMap底层数据结构是红黑树
ConcurrentHashMap底层数据结构是数组&#43;链表/红黑树
HashMap  简单总结HashMap：
 无序，允许为null，非同步 底层由散列表(哈希表)实现 初始容量和装载因子对HashMap影响挺大的，设置小了不好，设置大了也不好   new一个hashmap时会发生什么? HashMap有几个构造方法,但最主要的就是指定初始值以及负载因子的大小.如果不指定,默认hashmap的大小为16,负载因子的大小为0.75.
 HashMap的大小只能是2次幂,（因为只有大小为2次幂时，才能合理用位运算替代取模）
假如传一个10进去,实际大小是16.
假如传入一个7进去,hashmap最终大小是8,具体实现在tableSizeFor可以看到
 把元素放进hashmap的时候，需要算出这个元素所在的位置（hash），在hashmap里用的是位运算来代替取模，能够更加高效地算出该元素所在的位置。
而负载因子的大小决定着哈希表的扩容和哈希冲突。
比如默认hashmap的大小为16,负载因子的大小为0.75.这意味着数组最多只能放16×0.75=12个元素，一旦超过12个元素，则哈希表需要扩容。每次Put元素的时候都会检查hashmap的大小有没有超过这个阈值，如果超过则扩容。
鉴于（HashMap的大小只能是2次幂），所以扩容的时候默认扩容为原来的2倍。
 扩容是耗时的,也可以通过调高负载因子来减少扩容.
但是一般不推荐这样做,因为这样意味着哈希冲突的概率会增高,哈希冲突的概率增高同样会耗时(因为查找的速度变慢了)
 Put元素 怎么计算hash？
 put元素的时候，先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。好处是增加了随机性，减少了碰撞冲突的可能性。
 put和get的实现
put  首先对key做hash运算，计算出该key所在的index。
如果没碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来进行插入。
假如key相同的，则替换到原来的值。最后判断哈希表是否满了（当前哈希表大小×负载因子），如果满了，则扩容。
 get  还是对key做hash运算，计算出该key所在的index，然后判断是否有哈希冲突。
假如没有冲突则直接返回。假设有冲突则判断目前数据结构是链表还是红黑树，分别从不同的数据结构中取出。
 在hashmap中，怎么判断一个元素是否相同？ 首先比较hash值，随后会用==运算符和equals()来判断该元素是否相同。
说白了，就是：
如果只有hash值相同，那说明该元素hash冲突了，如果hash值和equal() || == 都相同，那说明该元素是同一个。
什么情况下会转红黑树？  当数组大小&amp;gt;64且链表的大小&amp;gt;8的时候才会将链表转为红黑树。当红黑树大小为6时，会退化为链表。
这里转红黑树退化为链表的操作主要出于查询和插入时对性能的考量
链表的查询时间复杂度为O(N),插入时间复杂度为O(1),红黑树查询和插入时间复杂度为O(logN)
 线程安全？  HashMap是线程不安全的，在多线程环境下，HashMap有可能会有数据丢失和获取不了最新数据的问题，比如线程A put进去了，线程B get不出来。
 LinkedHashMap  实际上继承了HashMap，在HashMap的基础上维护了一个双向链表。" />
<meta name="keywords"
  content='' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://kayleh.top/head-first-hashmap/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Head First Map - Kayleh" />
<meta name="twitter:description"
  content="深入浅出Map  Map是java里边是一个接口,常见的实现类有HashMap、LinkedHashMap、TreeMap和ConcurrentHashMap
 HashMap底层数据结构是数组&#43;链表/红黑树
LinkedHashMap底层数据结构是数组&#43;链表&#43;双向链表
TreeMap底层数据结构是红黑树
ConcurrentHashMap底层数据结构是数组&#43;链表/红黑树
HashMap  简单总结HashMap：
 无序，允许为null，非同步 底层由散列表(哈希表)实现 初始容量和装载因子对HashMap影响挺大的，设置小了不好，设置大了也不好   new一个hashmap时会发生什么? HashMap有几个构造方法,但最主要的就是指定初始值以及负载因子的大小.如果不指定,默认hashmap的大小为16,负载因子的大小为0.75.
 HashMap的大小只能是2次幂,（因为只有大小为2次幂时，才能合理用位运算替代取模）
假如传一个10进去,实际大小是16.
假如传入一个7进去,hashmap最终大小是8,具体实现在tableSizeFor可以看到
 把元素放进hashmap的时候，需要算出这个元素所在的位置（hash），在hashmap里用的是位运算来代替取模，能够更加高效地算出该元素所在的位置。
而负载因子的大小决定着哈希表的扩容和哈希冲突。
比如默认hashmap的大小为16,负载因子的大小为0.75.这意味着数组最多只能放16×0.75=12个元素，一旦超过12个元素，则哈希表需要扩容。每次Put元素的时候都会检查hashmap的大小有没有超过这个阈值，如果超过则扩容。
鉴于（HashMap的大小只能是2次幂），所以扩容的时候默认扩容为原来的2倍。
 扩容是耗时的,也可以通过调高负载因子来减少扩容.
但是一般不推荐这样做,因为这样意味着哈希冲突的概率会增高,哈希冲突的概率增高同样会耗时(因为查找的速度变慢了)
 Put元素 怎么计算hash？
 put元素的时候，先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。好处是增加了随机性，减少了碰撞冲突的可能性。
 put和get的实现
put  首先对key做hash运算，计算出该key所在的index。
如果没碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来进行插入。
假如key相同的，则替换到原来的值。最后判断哈希表是否满了（当前哈希表大小×负载因子），如果满了，则扩容。
 get  还是对key做hash运算，计算出该key所在的index，然后判断是否有哈希冲突。
假如没有冲突则直接返回。假设有冲突则判断目前数据结构是链表还是红黑树，分别从不同的数据结构中取出。
 在hashmap中，怎么判断一个元素是否相同？ 首先比较hash值，随后会用==运算符和equals()来判断该元素是否相同。
说白了，就是：
如果只有hash值相同，那说明该元素hash冲突了，如果hash值和equal() || == 都相同，那说明该元素是同一个。
什么情况下会转红黑树？  当数组大小&amp;gt;64且链表的大小&amp;gt;8的时候才会将链表转为红黑树。当红黑树大小为6时，会退化为链表。
这里转红黑树退化为链表的操作主要出于查询和插入时对性能的考量
链表的查询时间复杂度为O(N),插入时间复杂度为O(1),红黑树查询和插入时间复杂度为O(logN)
 线程安全？  HashMap是线程不安全的，在多线程环境下，HashMap有可能会有数据丢失和获取不了最新数据的问题，比如线程A put进去了，线程B get不出来。
 LinkedHashMap  实际上继承了HashMap，在HashMap的基础上维护了一个双向链表。" />
<meta name="twitter:site" content="https://kayleh.top" />
<meta name="twitter:creator" content="" />
<meta name="twitter:image"
  content="https://kayleh.top">


<meta property="og:type" content="article" />
<meta property="og:title" content="Head First Map - Kayleh">
<meta property="og:description"
  content="深入浅出Map  Map是java里边是一个接口,常见的实现类有HashMap、LinkedHashMap、TreeMap和ConcurrentHashMap
 HashMap底层数据结构是数组&#43;链表/红黑树
LinkedHashMap底层数据结构是数组&#43;链表&#43;双向链表
TreeMap底层数据结构是红黑树
ConcurrentHashMap底层数据结构是数组&#43;链表/红黑树
HashMap  简单总结HashMap：
 无序，允许为null，非同步 底层由散列表(哈希表)实现 初始容量和装载因子对HashMap影响挺大的，设置小了不好，设置大了也不好   new一个hashmap时会发生什么? HashMap有几个构造方法,但最主要的就是指定初始值以及负载因子的大小.如果不指定,默认hashmap的大小为16,负载因子的大小为0.75.
 HashMap的大小只能是2次幂,（因为只有大小为2次幂时，才能合理用位运算替代取模）
假如传一个10进去,实际大小是16.
假如传入一个7进去,hashmap最终大小是8,具体实现在tableSizeFor可以看到
 把元素放进hashmap的时候，需要算出这个元素所在的位置（hash），在hashmap里用的是位运算来代替取模，能够更加高效地算出该元素所在的位置。
而负载因子的大小决定着哈希表的扩容和哈希冲突。
比如默认hashmap的大小为16,负载因子的大小为0.75.这意味着数组最多只能放16×0.75=12个元素，一旦超过12个元素，则哈希表需要扩容。每次Put元素的时候都会检查hashmap的大小有没有超过这个阈值，如果超过则扩容。
鉴于（HashMap的大小只能是2次幂），所以扩容的时候默认扩容为原来的2倍。
 扩容是耗时的,也可以通过调高负载因子来减少扩容.
但是一般不推荐这样做,因为这样意味着哈希冲突的概率会增高,哈希冲突的概率增高同样会耗时(因为查找的速度变慢了)
 Put元素 怎么计算hash？
 put元素的时候，先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。好处是增加了随机性，减少了碰撞冲突的可能性。
 put和get的实现
put  首先对key做hash运算，计算出该key所在的index。
如果没碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来进行插入。
假如key相同的，则替换到原来的值。最后判断哈希表是否满了（当前哈希表大小×负载因子），如果满了，则扩容。
 get  还是对key做hash运算，计算出该key所在的index，然后判断是否有哈希冲突。
假如没有冲突则直接返回。假设有冲突则判断目前数据结构是链表还是红黑树，分别从不同的数据结构中取出。
 在hashmap中，怎么判断一个元素是否相同？ 首先比较hash值，随后会用==运算符和equals()来判断该元素是否相同。
说白了，就是：
如果只有hash值相同，那说明该元素hash冲突了，如果hash值和equal() || == 都相同，那说明该元素是同一个。
什么情况下会转红黑树？  当数组大小&amp;gt;64且链表的大小&amp;gt;8的时候才会将链表转为红黑树。当红黑树大小为6时，会退化为链表。
这里转红黑树退化为链表的操作主要出于查询和插入时对性能的考量
链表的查询时间复杂度为O(N),插入时间复杂度为O(1),红黑树查询和插入时间复杂度为O(logN)
 线程安全？  HashMap是线程不安全的，在多线程环境下，HashMap有可能会有数据丢失和获取不了最新数据的问题，比如线程A put进去了，线程B get不出来。
 LinkedHashMap  实际上继承了HashMap，在HashMap的基础上维护了一个双向链表。" />
<meta property="og:url" content="https://kayleh.top/head-first-hashmap/" />
<meta property="og:site_name" content="Head First Map" />
<meta property="og:image"
  content="https://kayleh.top">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2021-04-18 01:31:12 &#43;0800 CST" />










</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://kayleh.top">
        <svg class="octicon" height="32" viewBox="0 0 16 16" version="1.1" width="32">
          <path fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd"
            d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          <form target="_blank" action="https://www.google.com/search" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
              <input type="hidden" name="q" value="site:https://kayleh.top">
            </label>
          </form>
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://kayleh.top">
        <svg class="octicon octicon-mark-github v-align-middle" height="32" viewBox="0 0 16 16" version="1.1"
          width="32">
          <path fill-rule="evenodd"
            d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
          </path>
        </svg>
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>
  
<div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://kayleh.top">
                  <img class=" avatar-user"
                    src="http://cdn.jsdelivr.net/gh/kayleh/cdn/img/2.jpg"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://kayleh.top">Kayleh</a></span><span
                    class="path-divider">/</span><strong class="css-truncate-target mr-1" style="max-width: 410px"><a
                      href="https://kayleh.top/head-first-hashmap/">Head First Map</a></strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Sun, 18 Apr 2021 01:31:12 &#43;0800"
                    class="no-wrap">
                    Sun, 18 Apr 2021 01:31:12 &#43;0800</relative-time>

                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div class="file-header d-flex flex-md-items-center flex-items-start">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    1985 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="/tags/algorithm">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      algorithm
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5">
                <article class="markdown-body entry-content container-lg"><h1 id="深入浅出map">深入浅出Map</h1>
<blockquote>
<p>Map是java里边是一个接口,常见的实现类有HashMap、LinkedHashMap、TreeMap和ConcurrentHashMap</p>
</blockquote>
<p>HashMap底层数据结构是<code>数组+链表/红黑树</code></p>
<p>LinkedHashMap底层数据结构是<code>数组+链表+双向链表</code></p>
<p>TreeMap底层数据结构是<code>红黑树</code></p>
<p>ConcurrentHashMap底层数据结构是<code>数组+链表/红黑树</code></p>
<h2 id="hashmap">HashMap</h2>
<blockquote>
<p>简单总结HashMap：</p>
<ul>
<li><strong>无序，允许为null，非同步</strong></li>
<li><strong>底层由散列表(哈希表)实现</strong></li>
<li><strong>初始容量和装载因子对HashMap影响挺大的</strong>，设置小了不好，设置大了也不好</li>
</ul>
</blockquote>
<h4 id="new一个hashmap时会发生什么">new一个hashmap时会发生什么?</h4>
<p>HashMap有几个构造方法,但最主要的就是指定初始值以及负载因子的大小.如果不指定,默认hashmap的<strong>大小为16</strong>,<strong>负载因子的大小为0.75</strong>.</p>
<blockquote>
<p>HashMap的大小只能是2次幂,（因为只有大小为2次幂时，才能合理用位运算替代取模）</p>
<p>假如传一个10进去,实际大小是16.</p>
<p>假如传入一个7进去,hashmap最终大小是8,具体实现在tableSizeFor可以看到</p>
</blockquote>
<p>把元素放进hashmap的时候，需要算出这个元素所在的位置（hash），在hashmap里用的是位运算来代替取模，能够更加高效地算出该元素所在的位置。</p>
<p>而负载因子的大小决定着哈希表的扩容和哈希冲突。</p>
<p>比如默认hashmap的大小为16,负载因子的大小为0.75.这意味着数组最多只能放16×0.75=12个元素，一旦超过12个元素，则哈希表需要扩容。每次Put元素的时候都会检查hashmap的大小有没有超过这个阈值，如果超过则扩容。</p>
<p>鉴于（HashMap的大小只能是2次幂），所以扩容的时候默认扩容为原来的2倍。</p>
<blockquote>
<p>扩容是耗时的,也可以通过调高负载因子来减少扩容.</p>
<p>但是一般不推荐这样做,因为这样意味着哈希冲突的概率会增高,哈希冲突的概率增高同样会耗时(因为查找的速度变慢了)</p>
</blockquote>
<h4 id="put元素">Put元素</h4>
<p>怎么计算hash？</p>
<blockquote>
<p>put元素的时候，先算出正常的哈希值，然后与高16位做异或运算，产生最终的哈希值。好处是增加了随机性，减少了碰撞冲突的可能性。</p>
</blockquote>
<p>put和get的实现</p>
<h4 id="put">put</h4>
<blockquote>
<p>首先对key做hash运算，计算出该key所在的index。</p>
<p>如果没碰撞，直接放到数组中，如果碰撞了，需要判断目前数据结构是链表还是红黑树，根据不同的情况来进行插入。</p>
<p>假如key相同的，则替换到原来的值。最后判断哈希表是否满了（当前哈希表大小×负载因子），如果满了，则扩容。</p>
</blockquote>
<h4 id="get">get</h4>
<blockquote>
<p>还是对key做hash运算，计算出该key所在的index，然后判断是否有哈希冲突。</p>
<p>假如没有冲突则直接返回。假设有冲突则判断目前数据结构是链表还是红黑树，分别从不同的数据结构中取出。</p>
</blockquote>
<h4 id="在hashmap中怎么判断一个元素是否相同">在hashmap中，怎么判断一个元素是否相同？</h4>
<p>首先比较hash值，随后会用==运算符和equals()来判断该元素是否相同。</p>
<p>说白了，就是：</p>
<p>如果只有hash值相同，那说明该元素hash冲突了，如果hash值和equal() || == 都相同，那说明该元素是同一个。</p>
<h4 id="什么情况下会转红黑树">什么情况下会转红黑树？</h4>
<blockquote>
<p>当数组大小&gt;64且链表的大小&gt;8的时候才会将链表转为红黑树。当红黑树大小为6时，会退化为链表。</p>
<p>这里转红黑树退化为链表的操作主要出于查询和插入时对性能的考量</p>
<p>链表的查询时间复杂度为O(N),插入时间复杂度为O(1),红黑树查询和插入时间复杂度为O(logN)</p>
</blockquote>
<h4 id="线程安全">线程安全？</h4>
<blockquote>
<p>HashMap是线程不安全的，在多线程环境下，HashMap有可能会有数据丢失和获取不了最新数据的问题，比如线程A put进去了，线程B get不出来。</p>
</blockquote>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<blockquote>
<p>实际上继承了HashMap，在HashMap的基础上维护了一个双向链表。</p>
<p>有了这个双向链表，插入的顺序是有序的。</p>
<p>LinkedHashMap在遍历的时候，实际上是用的是双向链表来遍历的，所以LinkedHashMap的大小不会影响到遍历的性能</p>
</blockquote>
<h2 id="treemap">TreeMap</h2>
<blockquote>
<p>TreeMap的key不能为null（如果为null就不能排序），TreeMap有序是通过Comparator来进行比较的，如果</p>
<p>Comparator为null，那么就使用自然顺序</p>
</blockquote>
<h2 id="concurrenthashmap">ConcurrentHashMap</h2>
<blockquote>
<p>ConcurrentHashMap是JUC包下的线程安全的Map实现类，他能支持高并发的访问和更新。</p>
<p>线程安全的Map实现类还有HashTable，还有可以使用Collections来包装出一个线程安全的Map。</p>
<p>但是HashTable还是Collections来包装出来的，都比较低效，因为都是直接在外层套synchronize。</p>
<p>所以一般有线程安全问题考量的，都使用ConcurrentHashMap。</p>
</blockquote>
<p>ConcurrentHashMap通过在部分加锁和利用CAS算法来实现同步，在get的时候没有加锁，Node都用了volatile给修饰。</p>
<p>在扩容时，会给每个线程分配对应的区间，并且为了防止putVal导致数据不一致，会给线程的所负责的区间加锁。</p>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://kayleh.top">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://kayleh.top/js/github-style.js"></script>



</html>