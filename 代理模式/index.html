<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Kayleh">
  
  
  
  <link rel="prev" href="https://blog.kayleh.top/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" />
  <link rel="next" href="https://blog.kayleh.top/resume/" />
  <link rel="canonical" href="https://blog.kayleh.top/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           代理模式 | Kayleh
       
  </title>
  <meta name="title" content="代理模式 | Kayleh">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/blog.kayleh.top"
    },
    "articleSection" : "posts",
    "name" : "代理模式",
    "headline" : "代理模式",
    "description" : "\u003ch3 id=\u0022代理模式\u0022\u003e代理模式\u003c\/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e为其他对象提供一种代理以控制对这个对象的访问。\u003c\/em\u003e\u003c\/p\u003e\n\u003c\/blockquote\u003e",
    "inLanguage" : "en-us",
    "author" : "Kayleh",
    "creator" : "Kayleh",
    "publisher": "Kayleh",
    "accountablePerson" : "Kayleh",
    "copyrightHolder" : "Kayleh",
    "copyrightYear" : "2020",
    "datePublished": "2020-06-09 20:46:15 \u002b0800 CST",
    "dateModified" : "2020-06-09 20:46:15 \u002b0800 CST",
    "url" : "https:\/\/blog.kayleh.top\/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\/",
    "wordCount" : "656",
    "keywords" : [ "DesignPatterns", "Kayleh"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://blog.kayleh.top">Kayleh</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://blog.kayleh.top">Kayleh</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">代理模式</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://blog.kayleh.top" rel="author">Kayleh</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-06-09 itemprop="datePublished">June 9, 2020</time>
                </span>
                in
                
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <h3 id="代理模式">代理模式</h3>
<blockquote>
<p><em>为其他对象提供一种代理以控制对这个对象的访问。</em></p>
</blockquote>
<p>在**代理模式（Proxy Pattern）**中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<h2 id="介绍">介绍</h2>
<p>**意图：**为其他对象提供一种代理以控制对这个对象的访问。</p>
<p>**主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p>**何时使用：**想在访问一个类时做一些控制。</p>
<p>**如何解决：**增加中间层。</p>
<p>**关键代码：**实现与被代理类组合。</p>
<p><strong>应用实例：</strong> 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。</p>
<p><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。</p>
<p><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>
<p>**使用场景：**按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p>
<p><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<h2 id="实现">实现</h2>
<p>我们将创建一个 <em>Image</em> 接口和实现了 <em>Image</em> 接口的实体类。<em>ProxyImage</em> 是一个代理类，减少 <em>RealImage</em> 对象加载的内存占用。</p>
<p><em>ProxyPatternDemo</em>，我们的演示类使用 <em>ProxyImage</em> 来获取要加载的 <em>Image</em> 对象，并按照需求进行显示。</p>
<p><img src="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.jpg" alt="代理模式的 UML 图"></p>
<ul>
<li></li>
</ul>
<p>代理模式，即Proxy，它和Adapter模式很类似。我们先回顾Adapter模式，它用于把A接口转换为B接口：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> BAdapter <span style="color:#66d9ef">implements</span> B <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> A a<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">BAdapter</span><span style="color:#f92672">(</span>A a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">b</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        a<span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> AProxy <span style="color:#66d9ef">implements</span> A <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> A a<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AProxy</span><span style="color:#f92672">(</span>A a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">a</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>合着Proxy就是为了给A接口再包一层，这不是脱了裤子放屁吗？</p>
<p>当然不是。我们观察Proxy的实现A接口的方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">a</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这样写当然没啥卵用。但是，如果我们在调用<code>a.a()</code>的前后，加一些额外的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">a</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>getCurrentUser<span style="color:#f92672">().</span><span style="color:#a6e22e">isRoot</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">.</span><span style="color:#a6e22e">a</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> SecurityException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Forbidden&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这样一来，我们就实现了权限检查，只有符合要求的用户，才会真正调用目标方法，否则，会直接抛出异常。</p>
<p>有的童鞋会问，为啥不把权限检查的功能直接写到目标实例A的内部？</p>
<p>因为我们编写代码的原则有：</p>
<ul>
<li>职责清晰：一个类只负责一件事；</li>
<li>易于测试：一次只测一个功能。</li>
</ul>
<p>用Proxy实现这个权限检查，我们可以获得更清晰、更简洁的代码：</p>
<ul>
<li>A接口：只定义接口；</li>
<li>ABusiness类：只实现A接口的业务逻辑；</li>
<li>APermissionProxy类：只实现A接口的权限检查代理。</li>
</ul>
<p>如果我们希望编写其他类型的代理，可以继续增加类似ALogProxy，而不必对现有的A接口、ABusiness类进行修改。</p>
<p>实际上权限检查只是代理模式的一种应用。Proxy还广泛应用在：</p>
<h3 id="远程代理">远程代理</h3>
<p>远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。</p>
<h3 id="虚代理">虚代理</h3>
<p>虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p>
<h3 id="保护代理">保护代理</h3>
<p>保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。</p>
<h3 id="智能引用">智能引用</h3>
<p>智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。</p>
<p>我们来看一下如何应用代理模式编写一个JDBC连接池（<code>DataSource</code>）。我们首先来编写一个虚代理，即如果调用者获取到<code>Connection</code>后，并没有执行任何SQL操作，那么这个Connection Proxy实际上并不会真正打开JDBC连接。调用者代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">DataSource lazyDataSource <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LazyDataSource<span style="color:#f92672">(</span>jdbcUrl<span style="color:#f92672">,</span> jdbcUsername<span style="color:#f92672">,</span> jdbcPassword<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;get lazy connection...&#34;</span><span style="color:#f92672">);</span>
<span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>Connection conn1 <span style="color:#f92672">=</span> lazyDataSource<span style="color:#f92672">.</span><span style="color:#a6e22e">getConnection</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 并没有实际打开真正的Connection
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;get lazy connection...&#34;</span><span style="color:#f92672">);</span>
<span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>Connection conn2 <span style="color:#f92672">=</span> lazyDataSource<span style="color:#f92672">.</span><span style="color:#a6e22e">getConnection</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>PreparedStatement ps <span style="color:#f92672">=</span> conn2<span style="color:#f92672">.</span><span style="color:#a6e22e">prepareStatement</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;SELECT * FROM students&#34;</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 打开了真正的Connection
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>ResultSet rs <span style="color:#f92672">=</span> ps<span style="color:#f92672">.</span><span style="color:#a6e22e">executeQuery</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>rs<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>rs<span style="color:#f92672">.</span><span style="color:#a6e22e">getString</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;name&#34;</span><span style="color:#f92672">));</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>现在我们来思考如何实现这个<code>LazyConnectionProxy</code>。为了简化代码，我们首先针对<code>Connection</code>接口做一个抽象的代理类：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractConnectionProxy</span> <span style="color:#66d9ef">implements</span> Connection <span style="color:#f92672">{</span>

    <span style="color:#75715e">// 抽象方法获取实际的Connection:
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">abstract</span> Connection <span style="color:#a6e22e">getRealConnection</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">// 实现Connection接口的每一个方法:
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> Statement <span style="color:#a6e22e">createStatement</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> SQLException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> getRealConnection<span style="color:#f92672">().</span><span style="color:#a6e22e">createStatement</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> PreparedStatement <span style="color:#a6e22e">prepareStatement</span><span style="color:#f92672">(</span>String sql<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> SQLException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> getRealConnection<span style="color:#f92672">().</span><span style="color:#a6e22e">prepareStatement</span><span style="color:#f92672">(</span>sql<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#f92672">...</span><span style="color:#a6e22e">其他代理方法</span><span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>这个<code>AbstractConnectionProxy</code>代理类的作用是把<code>Connection</code>接口定义的方法全部实现一遍，因为<code>Connection</code>接口定义的方法太多了，后面我们要编写的<code>LazyConnectionProxy</code>只需要继承<code>AbstractConnectionProxy</code>，就不必再把<code>Connection</code>接口方法挨个实现一遍。</p>
<p><code>LazyConnectionProxy</code>实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LazyConnectionProxy</span> <span style="color:#66d9ef">extends</span> AbstractConnectionProxy <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> Supplier<span style="color:#f92672">&lt;</span>Connection<span style="color:#f92672">&gt;</span> supplier<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> Connection target <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">LazyConnectionProxy</span><span style="color:#f92672">(</span>Supplier<span style="color:#f92672">&lt;</span>Connection<span style="color:#f92672">&gt;</span> supplier<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">supplier</span> <span style="color:#f92672">=</span> supplier<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// 覆写close方法：只有target不为null时才需要关闭:
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">close</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> SQLException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>target <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Close connection: &#34;</span> <span style="color:#f92672">+</span> target<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">protected</span> Connection <span style="color:#a6e22e">getRealConnection</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>target <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            target <span style="color:#f92672">=</span> supplier<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> target<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>如果调用者没有执行任何SQL语句，那么<code>target</code>字段始终为<code>null</code>。只有第一次执行SQL语句时（即调用任何类似<code>prepareStatement()</code>方法时，触发<code>getRealConnection()</code>调用），才会真正打开实际的JDBC Connection。</p>
<p>最后，我们还需要编写一个<code>LazyDataSource</code>来支持这个<code>LazyConnecitonProxy</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LazyDataSource</span> <span style="color:#66d9ef">implements</span> DataSource <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> String url<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> String username<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> String password<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">LazyDataSource</span><span style="color:#f92672">(</span>String url<span style="color:#f92672">,</span> String username<span style="color:#f92672">,</span> String password<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">url</span> <span style="color:#f92672">=</span> url<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">username</span> <span style="color:#f92672">=</span> username<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">password</span> <span style="color:#f92672">=</span> password<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Connection <span style="color:#a6e22e">getConnection</span><span style="color:#f92672">(</span>String username<span style="color:#f92672">,</span> String password<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> SQLException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> LazyConnectionProxy<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
                Connection conn <span style="color:#f92672">=</span> DriverManager<span style="color:#f92672">.</span><span style="color:#a6e22e">getConnection</span><span style="color:#f92672">(</span>url<span style="color:#f92672">,</span> username<span style="color:#f92672">,</span> password<span style="color:#f92672">);</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Open connection: &#34;</span> <span style="color:#f92672">+</span> conn<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">return</span> conn<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>SQLException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> RuntimeException<span style="color:#f92672">(</span>e<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">});</span>
    <span style="color:#f92672">}</span>
    <span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>我们执行代码，输出如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">get lazy connection<span style="color:#f92672">...</span>
get lazy connection<span style="color:#f92672">...</span>
Open connection<span style="color:#f92672">:</span> com<span style="color:#f92672">.</span><span style="color:#a6e22e">mysql</span><span style="color:#f92672">.</span><span style="color:#a6e22e">jdbc</span><span style="color:#f92672">.</span><span style="color:#a6e22e">JDBC4Connection</span><span style="color:#a6e22e">@7a36aefa</span>
小明
小红
小军
小白
<span style="color:#f92672">...</span>
Close connection<span style="color:#f92672">:</span> com<span style="color:#f92672">.</span><span style="color:#a6e22e">mysql</span><span style="color:#f92672">.</span><span style="color:#a6e22e">jdbc</span><span style="color:#f92672">.</span><span style="color:#a6e22e">JDBC4Connection</span><span style="color:#a6e22e">@7a36aefa</span>
</code></pre></div><p>可见第一个<code>getConnection()</code>调用获取到的<code>LazyConnectionProxy</code>并没有实际打开真正的JDBC Connection。</p>
<p>使用连接池的时候，我们更希望能重复使用连接。如果调用方编写这样的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">DataSource pooledDataSource <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> PooledDataSource<span style="color:#f92672">(</span>jdbcUrl<span style="color:#f92672">,</span> jdbcUsername<span style="color:#f92672">,</span> jdbcPassword<span style="color:#f92672">);</span>
<span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>Connection conn <span style="color:#f92672">=</span> pooledDataSource<span style="color:#f92672">.</span><span style="color:#a6e22e">getConnection</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>Connection conn <span style="color:#f92672">=</span> pooledDataSource<span style="color:#f92672">.</span><span style="color:#a6e22e">getConnection</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 获取到的是同一个Connection
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
<span style="color:#66d9ef">try</span> <span style="color:#f92672">(</span>Connection conn <span style="color:#f92672">=</span> pooledDataSource<span style="color:#f92672">.</span><span style="color:#a6e22e">getConnection</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 获取到的是同一个Connection
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>调用方并不关心是否复用了<code>Connection</code>，但从<code>PooledDataSource</code>获取的<code>Connection</code>确实自带这个优化功能。如何实现可复用<code>Connection</code>的连接池？答案仍然是使用代理模式。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PooledConnectionProxy</span> <span style="color:#66d9ef">extends</span> AbstractConnectionProxy <span style="color:#f92672">{</span>
    <span style="color:#75715e">// 实际的Connection:
</span><span style="color:#75715e"></span>    Connection target<span style="color:#f92672">;</span>
    <span style="color:#75715e">// 空闲队列:
</span><span style="color:#75715e"></span>    Queue<span style="color:#f92672">&lt;</span>PooledConnectionProxy<span style="color:#f92672">&gt;</span> idleQueue<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">PooledConnectionProxy</span><span style="color:#f92672">(</span>Queue<span style="color:#f92672">&lt;</span>PooledConnectionProxy<span style="color:#f92672">&gt;</span> idleQueue<span style="color:#f92672">,</span> Connection target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">idleQueue</span> <span style="color:#f92672">=</span> idleQueue<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">target</span> <span style="color:#f92672">=</span> target<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">close</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> SQLException <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Fake close and released to idle queue for future reuse: &#34;</span> <span style="color:#f92672">+</span> target<span style="color:#f92672">);</span>
        <span style="color:#75715e">// 并没有调用实际Connection的close()方法,
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 而是把自己放入空闲队列:
</span><span style="color:#75715e"></span>        idleQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">offer</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">protected</span> Connection <span style="color:#a6e22e">getRealConnection</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> target<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>复用连接的关键在于覆写<code>close()</code>方法，它并没有真正关闭底层JDBC连接，而是把自己放回一个空闲队列，以便下次使用。</p>
<p>空闲队列由<code>PooledDataSource</code>负责维护：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PooledDataSource</span> <span style="color:#66d9ef">implements</span> DataSource <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> String url<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> String username<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> String password<span style="color:#f92672">;</span>

    <span style="color:#75715e">// 维护一个空闲队列:
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> Queue<span style="color:#f92672">&lt;</span>PooledConnectionProxy<span style="color:#f92672">&gt;</span> idleQueue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayBlockingQueue<span style="color:#f92672">&lt;&gt;(</span>100<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">PooledDataSource</span><span style="color:#f92672">(</span>String url<span style="color:#f92672">,</span> String username<span style="color:#f92672">,</span> String password<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">url</span> <span style="color:#f92672">=</span> url<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">username</span> <span style="color:#f92672">=</span> username<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">password</span> <span style="color:#f92672">=</span> password<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> Connection <span style="color:#a6e22e">getConnection</span><span style="color:#f92672">(</span>String username<span style="color:#f92672">,</span> String password<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> SQLException <span style="color:#f92672">{</span>
        <span style="color:#75715e">// 首先试图获取一个空闲连接:
</span><span style="color:#75715e"></span>        PooledConnectionProxy conn <span style="color:#f92672">=</span> idleQueue<span style="color:#f92672">.</span><span style="color:#a6e22e">poll</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>conn <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 没有空闲连接时，打开一个新连接:
</span><span style="color:#75715e"></span>            conn <span style="color:#f92672">=</span> openNewConnection<span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Return pooled connection: &#34;</span> <span style="color:#f92672">+</span> conn<span style="color:#f92672">.</span><span style="color:#a6e22e">target</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> conn<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> PooledConnectionProxy <span style="color:#a6e22e">openNewConnection</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> SQLException <span style="color:#f92672">{</span>
        Connection conn <span style="color:#f92672">=</span> DriverManager<span style="color:#f92672">.</span><span style="color:#a6e22e">getConnection</span><span style="color:#f92672">(</span>url<span style="color:#f92672">,</span> username<span style="color:#f92672">,</span> password<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Open new connection: &#34;</span> <span style="color:#f92672">+</span> conn<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> PooledConnectionProxy<span style="color:#f92672">(</span>idleQueue<span style="color:#f92672">,</span> conn<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#f92672">...</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>我们执行调用方代码，输出如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">Open new connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa
Fake close and released to idle queue <span style="color:#66d9ef">for</span> future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa
Return pooled connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa
Fake close and released to idle queue <span style="color:#66d9ef">for</span> future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa
Return pooled connection: com.mysql.jdbc.JDBC4Connection@61ca2dfa
Fake close and released to idle queue <span style="color:#66d9ef">for</span> future reuse: com.mysql.jdbc.JDBC4Connection@61ca2dfa
</code></pre></div><p>除了第一次打开了一个真正的JDBC Connection，后续获取的<code>Connection</code>实际上是同一个JDBC Connection。但是，对于调用方来说，完全不需要知道底层做了哪些优化。</p>
<p>我们实际使用的DataSource，例如HikariCP，都是基于代理模式实现的，原理同上，但增加了更多的如动态伸缩的功能（一个连接空闲一段时间后自动关闭）。</p>
<p>有的童鞋会发现Proxy模式和Decorator模式有些类似。确实，这两者看起来很像，但区别在于：Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</p>
    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Kayleh </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://blog.kayleh.top/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/>https://blog.kayleh.top/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://blog.kayleh.top/tags/designpatterns/">
                    #DesignPatterns</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://blog.kayleh.top">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://blog.kayleh.top/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" class="prev" rel="prev" title="享元模式"><i class="iconfont icon-left"></i>&nbsp;享元模式</a>
         
        
        <a href="https://blog.kayleh.top/resume/" class="next" rel="next" title="RESUME">RESUME&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <script async="" src="https://widget.daovoice.io/widget/38b1c911.js" charset="utf-8"></script>
    <script data-ad-client="ca-pub-7457165067653912" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle"style="display:inline-block;width:728px;height:90px"data-ad-client="ca-pub-7457165067653912"data-ad-slot="9837525717"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
    <script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?2cd1dc193190f18fed292accb735c684";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script>
   <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle"style="display:inline-block;width:728px;height:90px"data-ad-client="ca-pub-7457165067653912"data-ad-slot="9837525717"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://blog.kayleh.top">Kayleh</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
